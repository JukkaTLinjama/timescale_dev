<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
        <title>History Timeline v45.5</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link rel="stylesheet" href="style.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <h1 id="page-title">
        History at your fingertips — Big Bang to 2025
        <span style="font-size:0.65em; color:#9e9d9d;">v45.5</span>
    </h1>

    <div id="info-toggle">?</div>
<div id="info-box" style="display:none;">
    <div id="help-message">
        <p><em>Experimental visualization</em> of history across an immense time span.</p>
        <p>A vertical, <em>zoomable logarithmic timeline</em> of key events from the Big Bang to the present
            (2025).</p>
        <p>Events are grouped into <em>partly overlapping themes</em> that you can bring to the front.</p>

        <hr style="border:none; border-top:1px solid #ddd; margin:8px 0;">
        <!-- pikavinkit -->
        <p><em>Tips:</em> Pinch/scroll content or swipe L/R to zoom · Click a theme card to focus · Tap an event
            for notes</p>
    </div>

    <!-- status päivittyy skriptistä -->
    <div id="status-message" style="font-size:0.75em; color:#666; margin-top:2px;">
        Loading…
    </div>

    <!-- erillinen author-kenttä, EI muutu skriptissä -->
    <div id="author" style="font-size:0.75em; color:#666; margin-top:6px;">
        Authors: Jukka Linjama &amp; ChatGPT 5.0. 
    </div>

    <div id="license-info" style="font-size:0.7em; color:#666; margin-top:6px;">
        Project in <a href="https://github.com/JukkaTLinjama/log-aikajana" target="_blank">Github</a>
        Shared as an <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>
        experiment.<br>
        Enjoy &amp; share!
    </div>
</div>

    <div id="timeline-container">
        <svg id="timeline"></svg>
    </div>

    <div id="page-footer">© 2025 JL · CC BY 4.0</div>

    <script>
        // Debug switch via ?debug=1
        (function () {
            const u = new URL(location.href);
            const dbg = u.searchParams.get("debug") === "1";
            // näkyvä pieni virhepalkki vain debug-tilassa
            if (dbg) {
                const bar = document.createElement("div");
                bar.id = "debug-bar";
                bar.style.cssText = "position:fixed;left:0;right:0;bottom:0;z-index:99999;font:12px/1.4 system-ui;padding:6px 10px;background:#300;color:#fdd;display:none";
                bar.textContent = "Debug on. Errors will appear here.";
                document.addEventListener("DOMContentLoaded", () => document.body.appendChild(bar));
                window.__DBG__ = true;
                window.addEventListener("error", (e) => {
                    bar.style.display = "block";
                    bar.textContent = "Error: " + (e.message || "unknown");
                    console.error("[timeline:error]", e.message, e.error);
                });
                window.addEventListener("unhandledrejection", (e) => {
                    bar.style.display = "block";
                    bar.textContent = "Promise error: " + (e.reason && (e.reason.message || e.reason));
                    console.error("[timeline:promise]", e.reason);
                });
                console.log("%c[debug] enabled", "color:#9f9");
            }
        })();
    </script>

    <!-- Lightweight helpers (no side effects). Loaded before timeline.js -->
    <script>
        (function () {
            if (window.Util) return; // avoid double-load
            const Util = {};

            /** Try/catch wrapper for draw/layout functions. */
            Util.safe = function safe(fn, label) {
                try { return (typeof fn === "function") ? fn() : undefined; }
                catch (err) {
                    const msg = `[${label}] ${err && err.message ? err.message : err}`;
                    console.error("[timeline:render]", label, err);
                    const bar = document.getElementById("debug-bar");
                    if (bar) { bar.style.display = "block"; bar.textContent = "Render error: " + msg; }
                }
            };

            /** Debounce helper. */
            Util.debounce = function debounce(fn, ms) {
                let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
            };

            /** Perf timer: logs only when debug (?debug=1) is on. */
            Util.timed = function timed(label, fn) {
                const t0 = performance.now();
                const out = fn();
                const t1 = performance.now();
                if (window.__DBG__) console.log(`[perf] ${label}: ${(t1 - t0).toFixed(1)} ms`);
                return out;
            };

            /** Clamp helper. */
            Util.clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

            Util.textHaloOffset = function (yEvt, yFoc) {
                const R = 40, MAX = 8;
                const dy = yEvt - yFoc, ady = Math.abs(dy);
                if (ady === 0 || ady >= R) return 0;
                const t = 1 - ady / R;
                return Math.sign(dy) * MAX * Math.pow(t, 1.0);
            };
            // ---------------- Card text helpers (pure, DOM-free) ----------------

            /** Preferred display label for an event (falls back to 'label'). */
            Util.eventLabel = function (ev) {
                return (ev?.display_label || ev?.label || '').toString();
            };

            /** One-line meta string (e.g., year + theme if present). */
            Util.eventMeta = function (ev) {
                const year = (ev?.year ?? '').toString();
                const theme = ev?.theme ? `Theme: ${ev.theme}` : null;
                return [year, theme].filter(Boolean).join(' · ');
            };

            /** Safe truncation with ellipsis; avoids breaking short strings. */
            Util.truncate = function (str, max = 60, suffix = '…') {
                const s = (str ?? '').toString();
                if (max <= 0) return '';
                if (s.length <= max) return s;
                // preserve word boundary if possible
                const cut = s.slice(0, max - suffix.length);
                const ws = cut.lastIndexOf(' ');
                return (ws >= 24 ? cut.slice(0, ws) : cut) + suffix;
            };
            // --- Card metrics (pure, DOM-free except bbox reads) ---
            // Computes paddings and rect based on measured text heights.
            Util.cardMetrics = function (titleSel, groupSel, yTopEv, yBotEv, viewH) {
                const titleH = Math.ceil((() => { try { return titleSel.node().getBBox().height; } catch { return 10; } })()) || 10;
                const tmp = groupSel.append("text").attr("class", "event-label").attr("visibility", "hidden").text("X");
                const evH = Math.ceil((() => { try { return tmp.node().getBBox().height; } catch { return 9; } })()) || 9;
                tmp.remove();

                const topPad = titleH + 6;
                const botPad = Math.ceil(evH * 2.2) + 8;
                const yRect = Math.min(yTopEv, yBotEv) - topPad;
                const hRect = Math.abs(yBotEv - yTopEv) + topPad + botPad;

                const fullyAbove = (yRect + hRect) < 15;
                const fullyBelow = yRect > viewH;

                return { topPad, botPad, yRect, hRect, fullyAbove, fullyBelow };
            };

            window.Util = Util;
        })();
    </script>
    <script>
        // -----------------------------------------------------------
        // TS_CFG / TS_DELAY
        // Global configuration objects used by timeline.js
        // Keep them here so values are easy to tweak without touching JS files.
        // -----------------------------------------------------------
        window.TS_CFG = {
            // Margins for the timeline viewport (pixels)
            margin: { top: 12, right: 54, bottom: 12, left: 54 },

            // Right-side zoom bar dimensions
            zoomBar: { width: 22, gap: 10 },

            // Event card layout parameters
            card: { minW: 160, pad: 10 },

            // Color palette used for event themes
            palette: ["#6372b2ff", "#70a8c6", "#4b9fa8", "#368d60ff", "#5a9646ff"],

            // Prefocus halo behavior (for focus highlight transitions)
            prefocus: { radiusPx: 16, hysteresisPx: 8 }
        };

        // Global timing delays for UI interactions (ms)
        window.TS_DELAY = { ACTIVATE: 1000, ZOOM: 1500 };
    </script>

    <script>
        // -----------------------------------------------------------
        // InfoBox module
        // Handles the small popup panel showing detailed info about an event.
        // Encapsulated in an IIFE so it doesn't leak global variables.
        // Accessible through window.InfoBox.show(event, screenBox)
        // and window.InfoBox.hide().
        // -----------------------------------------------------------
        (function () {
            const infoCfg = { margin: 10 };  // minimal distance from window edges (px)
            let infoEl = null;               // singleton DOM element for the popup

            // Ensure the info box element exists (lazy creation)
            function ensureInfoEl() {
                if (infoEl && infoEl.parentNode) return infoEl;
                infoEl = document.createElement('div');
                infoEl.id = 'event-info';
                document.body.appendChild(infoEl);
                // Prevent clicks inside the box from bubbling (so it doesn’t close)
                infoEl.addEventListener('click', e => e.stopPropagation());
                return infoEl;
            }
            // Build inner HTML structure for the info popup based on event data
            function buildEventHTML(ev) {
                const label = ev?.display_label || ev?.label || 'Event';
                const year = (ev?.year ?? '').toString();
                const meta = [year, ev?.theme ? `Theme: ${ev.theme}` : null]
                    .filter(Boolean)
                    .join(' · ');

                // Prefer localized comments prepared by DataUtil; fallback to raw comments
                const comments = (typeof ev?.display_comments === 'string' && ev.display_comments.trim().length > 0)
                    ? ev.display_comments.trim()
                    : ((typeof ev?.comments === 'string') ? ev.comments.trim() : '');

                // Optional reference/link (keep current behavior)
                const ref = (ev?.ref || '').trim();
                const link = ref && /^https?:\/\//i.test(ref)
                    ? `<div class="hint">Ref: <a href="${ref}" target="_blank" rel="noopener">link</a></div>`
                    : (ref ? `<div class="hint">Ref: ${ref}</div>` : ``);

                const body = comments
                    ? `<div class="body">${comments}</div>`
                    : `<div class="body" style="opacity:.8;">(No notes)</div>`;

                return `
                    <div class="title">${label}</div>
                    <div class="meta">${meta}</div>
                    ${body}${link}
                    <div class="hint">Tip: click outside to close.</div>
                    `;
            }

            // Show the info box at a screen position derived from the event’s bounding box
            function show(ev, screenBox) {
                const el = ensureInfoEl();
                el.innerHTML = buildEventHTML(ev);
                el.classList.remove('is-visible');
                // Initial hidden state for animation (fade + small scale)
                el.style.visibility = 'hidden';
                el.style.opacity = '0';
                el.style.transform = 'translateY(6px) scale(0.98)';

                requestAnimationFrame(() => {
                    const rect = el.getBoundingClientRect();
                    const M = infoCfg.margin;
                    let x = Math.round(screenBox.left + 12);
                    let y = Math.round(screenBox.top - rect.height - 8);

                    // If it would go offscreen above, move below the event instead
                    if (y < M) y = Math.round(screenBox.bottom + 8);
                    // Clamp to right and bottom edges
                    if (x + rect.width + M > innerWidth)
                        x = Math.max(M, innerWidth - rect.width - M);
                    if (y + rect.height + M > innerHeight)
                        y = Math.max(M, innerHeight - rect.height - M);

                    el.style.left = `${x}px`;
                    el.style.top = `${y}px`;

                    // Trigger CSS transition to visible state
                    requestAnimationFrame(() => {
                        el.style.visibility = '';
                        el.style.opacity = '';
                        el.style.transform = '';
                        el.classList.add('is-visible');
                    });
                });
            }

            // Hide the info box (simply remove visible class)
            function hide() {
                const el = ensureInfoEl();
                el.classList.remove('is-visible');
            }

            // Close on click outside or Escape key
            document.addEventListener('click', hide);
            document.addEventListener('keydown', e => { if (e.key === 'Escape') hide(); });

            // Expose public API
            window.InfoBox = { show, hide };
        })();
    </script>

    <script>
        // -----------------------------------------------
        // SwipeZoom module: handles touch and mouse gestures for zooming and panning
        // Horizontal swipe in center area → zoom in/out
        // Vertical swipe outside center area → pan up/down
        // This replaces the old setupGlobalSwipeZoom() in timeline.js
        // -----------------------------------------------
        (function () {
            /**
             * Attach gesture handling to an SVG element.
             * @param {d3.Selection} svgSel - the d3 selection for main SVG
             * @param {d3.ZoomBehavior} zoomBehavior - the D3 zoom behavior already created
             * @param {object} opts - optional parameters
             *   innerHeight: function returning window height (used to detect center zone)
             */
            function attach(svgSel, zoomBehavior, opts) {
                const innerHeight = (opts && opts.innerHeight) || (() => window.innerHeight);

                // --- gesture tuning constants ---
                const DEAD = 3;              // minimal movement before mode is decided
                const DOM_RATIO = 1.5;       // horizontal dominance threshold
                const SENS_TOUCH = -0.006;   // zoom sensitivity for touch
                const SENS_MOUSE = -0.003;   // zoom sensitivity for mouse
                const STEP = 20;             // max delta per frame
                const CLAMP_MIN = 0.95;      // minimal scale per step
                const CLAMP_MAX = 1.05;      // maximal scale per step

                // --- internal state ---
                let active = false;          // pointer currently down
                let mode = null;             // 'zoom' | 'pan' | null
                let startX = 0, startY = 0, lastX = 0, lastY = 0;
                let startInCenter = false;     // did gesture start in center zone?

                // --- helper: check if pointer Y is within the central zoom zone ---
                function inCenterZone(y) {
                    const H = innerHeight();
                    const zoneH = Math.max(80, Math.min(H * 0.36, 160)); // 80–160px or ~1/3 screen
                    const y0 = (H - zoneH) / 2, y1 = y0 + zoneH;
                    return y >= y0 && y <= y1;
                }

                const isTouch = (e) => e.pointerType === 'touch';
                const svgNode = svgSel.node();
                const contEl = document.getElementById('timeline-container');

                // --- visual feedback class toggle ---
                function setGestureActive(on) {
                    if (on) {
                        svgNode.classList.add('gesture-active');
                        if (contEl) contEl.classList.add('gesture-active');
                    } else {
                        svgNode.classList.remove('gesture-active');
                        if (contEl) contEl.classList.remove('gesture-active');
                    }
                }

                // -----------------------------------------------
                // pointerdown → start tracking
                // -----------------------------------------------
                svgNode.addEventListener('pointerdown', (e) => {
                    if (!e.isPrimary) return;        // ignore secondary touches
                    active = true; mode = null;
                    startX = lastX = e.clientX;
                    startY = lastY = e.clientY;
                    startInCenter = inCenterZone(e.clientY);
                    try { e.target.setPointerCapture(e.pointerId); } catch { }
                    e.stopPropagation();
                }, { passive: true, capture: true });

                // -----------------------------------------------
                // pointermove → decide mode and perform zoom/pan
                // -----------------------------------------------
                svgNode.addEventListener('pointermove', (e) => {
                    if (!active || !e.isPrimary) return;
                    const dxTot = e.clientX - startX;
                    const dyTot = e.clientY - startY;

                    // --- determine mode when movement passes threshold ---
                    if (mode === null && (Math.abs(dxTot) >= DEAD || Math.abs(dyTot) >= DEAD)) {
                        const horizDominates = (Math.abs(dxTot) > Math.abs(dyTot) * DOM_RATIO);
                        mode = (horizDominates && startInCenter) ? 'zoom' : 'pan';
                        setGestureActive(true);
                    }

                    // --- zoom mode ---
                    if (mode === 'zoom') {
                        const dxStep = Math.max(-STEP, Math.min(STEP, e.clientX - lastX));
                        if (Math.abs(dxStep) >= DEAD) {
                            lastX = e.clientX;
                            const sens = isTouch(e) ? SENS_TOUCH : SENS_MOUSE;
                            const factor = Math.max(CLAMP_MIN, Math.min(CLAMP_MAX, 1 + dxStep * sens));
                            // D3 handles scaling relative to pointer position
                            svgSel.call(zoomBehavior.scaleBy, factor, [e.clientX, e.clientY]);
                        }
                        e.stopPropagation();
                        return;
                    }

                    // --- pan mode ---
                    if (mode === 'pan') {
                        const dyStep = Math.max(-STEP, Math.min(STEP, e.clientY - lastY));
                        if (Math.abs(dyStep) >= DEAD) {
                            lastY = e.clientY;
                            svgSel.call(zoomBehavior.translateBy, 0, dyStep);
                        }
                        e.stopPropagation();
                        return;
                    }

                    e.stopPropagation();
                }, { passive: true, capture: true });

                // -----------------------------------------------
                // pointerup / cancel / lostcapture → reset
                // -----------------------------------------------
                const end = () => {
                    active = false; mode = null;
                    setGestureActive(false);
                };
                svgNode.addEventListener('pointerup', end, { passive: true, capture: true });
                svgNode.addEventListener('pointercancel', end, { passive: true, capture: true });
                svgNode.addEventListener('lostpointercapture', end, { passive: true, capture: true });
            }

            // Expose globally for timeline.js
            window.SwipeZoom = { attach };
        })();
    </script>
    <script>
        // -------------------------------------------------------
        // Ticks: compute major/minor tick values for a log domain
        // - majors: 10^n within [d0, d1]
        // - minors: 2..9 × 10^n within [d0, d1] (optional)
        // Keep this pure (no DOM), so it's easy to move to utils.js later.
        // -------------------------------------------------------
        (function () {
            function majorsFromDomain(d0, d1) {
                // Ensure ascending domain
                if (d0 > d1) [d0, d1] = [d1, d0];
                const n0 = Math.floor(Math.log10(d0));
                const n1 = Math.floor(Math.log10(d1));
                const values = [];
                for (let e = n0; e <= n1; e++) {
                    const v = Math.pow(10, e);
                    if (v >= d0 && v <= d1) values.push(v);
                }
                // Exponents parallel to major values (for label building)
                const exponents = [];
                for (let e = n0; e <= n1; e++) exponents.push(e);
                return { exponents, values };
            }

            function minorsFromDomain(d0, d1, showMinor) {
                if (!showMinor) return [];
                if (d0 > d1) [d0, d1] = [d1, d0];
                const out = [];
                const n0 = Math.floor(Math.log10(d0));
                const n1 = Math.floor(Math.log10(d1));
                for (let e = n0; e <= n1; e++) {
                    const base = Math.pow(10, e);
                    for (let m = 2; m <= 9; m++) {
                        const v = m * base;
                        if (v >= d0 && v <= d1) out.push(v);
                    }
                }
                return out;
            }

            window.Ticks = { majorsFromDomain, minorsFromDomain };
        })();
    </script>
    <script>
        // -------------------------------------------------------
        // CenterBand: pure math for the center zone geometry
        // Computes the vertical center line (midY), the zoom zone band (zoneY/zoneH),
        // and the horizontal endpoints (xLeft/xRight) for the center hairline.
        // Inputs are plain numbers; no DOM access here to keep it reusable.
        // -------------------------------------------------------
        (function () {
            /**
             * Compute geometry for the center band and hairline.
             * @param {number} w - svg width (outer)
             * @param {number} h - svg height (outer)
             * @param {number|NaN} axisRight - right edge (px) of the axis group, or NaN if unknown
             * @param {number|NaN} zoomBarLeft - left edge (px) of the zoom bar/track, or NaN if unknown
             * @returns {{zoneY:number, zoneH:number, midY:number, xLeft:number, xRight:number}}
             */
            function compute(w, h, axisRight, zoomBarLeft) {
                // Vertical band in the middle of the screen (used as "zoom allowed" zone)
                const zoneH = Math.max(80, Math.min(h * 0.36, 160)); // clamp 80–160 px
                const zoneY = (h - zoneH) / 2;
                const midY = Math.round(h / 2);

                // Horizontal endpoints: keep the hairline clear of axis and zoom bar
                const DEFAULT_LEFT_INSET = 14; // fallback padding from the left edge
                const DEFAULT_RIGHT_INSET = 4;  // fallback padding from the right edge
                const AXIS_GAP = 1;            // extra space after axis
                const ZOOMB_GAP = 15;           // extra space before zoom bar

                // Build endpoints with sensible fallbacks
                let xLeft = Number.isFinite(axisRight) ? Math.ceil(axisRight + AXIS_GAP) : DEFAULT_LEFT_INSET;
                let xRight = Number.isFinite(zoomBarLeft) ? Math.floor(zoomBarLeft - ZOOMB_GAP) : (w - DEFAULT_RIGHT_INSET);

                // Clamp to viewport
                xLeft = Math.max(0, Math.min(xLeft, w - DEFAULT_RIGHT_INSET));
                xRight = Math.max(DEFAULT_LEFT_INSET, Math.min(xRight, w));

                // If span is too short, relax a bit but stay reasonable
                const span = xRight - xLeft;
                if (span < w * 0.3) {
                    const leftRelax = Number.isFinite(axisRight) ? Math.min(axisRight + AXIS_GAP, 40) : 0;
                    const rightRelax = Number.isFinite(zoomBarLeft) ? Math.min((w - zoomBarLeft) + ZOOMB_GAP, 40) : 0;
                    xLeft = DEFAULT_LEFT_INSET + leftRelax;
                    xRight = w - DEFAULT_RIGHT_INSET - rightRelax;
                }

                // Final safety: ensure at least a minimal centered segment
                if ((xRight - xLeft) < 24) {
                    const cx = Math.round(w / 2);
                    xLeft = cx - 12;
                    xRight = cx + 12;
                }

                return { zoneY, zoneH, midY, xLeft, xRight };
            }

            // Expose as a tiny module
            window.CenterBand = { compute };
        })();
    </script>
<script>
    // -------------------------------------------------------
    // DataUtil: normalizeData()
    // Preprocesses loaded eventsDB.json:
    //  - merges group.theme into each event
    //  - applies i18n labels for the chosen language (from metadata.locale_default)
    //  - extracts theme order and colors from metadata.ui
    // -------------------------------------------------------
    (function () {
        function normalizeData(data, langFromCaller) {
            // Read from 'metadata' (the actual key in eventsDB.json)
            const meta = data.metadata || {};
            const ui = meta.ui || {};
            const themeOrder = Array.isArray(ui.themeOrder) ? ui.themeOrder : null;
            const themeColors = ui.themeColors || null;

            // Choose language: caller can pass one, otherwise use metadata.locale_default
            const lang = langFromCaller || meta.locale_default || "fi";

            // Flatten groups → inject theme into each event and build display_label/comments
            const events = (data.events || []).flatMap(g =>
                (g.events || []).map(e => ({
                    ...e,
                    theme: g.theme,
                    display_label:
                        (e.i18n && e.i18n[lang] && e.i18n[lang].label)
                            ? e.i18n[lang].label
                            : e.label,
                    display_comments:
                        (e.i18n && e.i18n[lang] && e.i18n[lang].comments)
                            ? e.i18n[lang].comments
                            : (e.comments || "")
                }))
            );

            // Derive themes, respecting metadata.ui.themeOrder when present
            const themes = themeOrder
                ? themeOrder.filter(t => events.some(e => e.theme === t))
                : Array.from(new Set(events.map(e => e.theme)));

            return { events, themes, themeColors, langUsed: lang };
        }

        // Expose globally for timeline.js
        window.DataUtil = { normalizeData };
    })();
</script>
<script>
    /* ----------------------------------------------------------
       v45.1 — Data preparation and absolute "present" events
       ----------------------------------------------------------
       This script moves data loading from timeline.js to index.html.
       It:
       1. Fetches eventsDB.json and metadata.
       2. Normalizes via DataUtil.normalizeData (already loaded).
       3. Anchors "present" events to the real wall clock time.
       4. Exposes the combined data as window.TS_DATA for timeline.js.
       ---------------------------------------------------------- */

    (function () {
        /* --- Time utilities (candidates for utils/timeUtils.js) --- */

        const YEAR_MS = 365.2425 * 24 * 3600 * 1000;
        const yearsBetween = (a, b) => Math.abs(b - a) / YEAR_MS;

        const floorToSecond = d => (d = new Date(d), d.setMilliseconds(0), d);
        const floorToMinute = d => (d = new Date(d), d.setSeconds(0, 0), d);
        const floorToHour = d => (d = new Date(d), d.setMinutes(0, 0, 0), d);
        const floorToDay = d => (d = new Date(d), d.setHours(0, 0, 0, 0), d);

       /* --- Build present anchors (stable header + 4-second trail) --- */
        function buildPresent() {
            const now = new Date(); // local system clock

            // format helpers
            const pad = n => String(n).padStart(2, "0");
            const toClock = d => `${pad(d.getHours())}:${pad(d.getMinutes())}`;
            const toClockSec = d => `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
            const toDate = d => `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
            const toMonth = d => `${d.getFullYear()}-${pad(d.getMonth() + 1)}`;
            const toYear = d => `${d.getFullYear()}`;

            // “starts of” current periods
            const secStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(),
                now.getHours(), now.getMinutes(), now.getSeconds(), 0);
            const minStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(),
                now.getHours(), now.getMinutes(), 0, 0);
            const hourStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(),
                now.getHours(), 0, 0, 0);
            const dayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
            const monthStart = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0);
            const yearStart = new Date(now.getFullYear(), 0, 1, 0, 0, 0, 0);

            // 0) STABLE HEADER ANCHOR ~0.1 s from now → keeps card top steady
            const anchor = {
                id: 'present-header-anchor',
                label: '',                // no visible text
                theme: 'present',
                t: new Date(now.getTime() - 10), // ~0.1 s before now
                isAnchor: true            // we’ll hide it in drawing
            };

            // 1) “this …” anchors
            const main = [
                { id: 'present-this-sec', label: `${toClockSec(now)} (this sec)`, theme: 'present', t: secStart },
                { id: 'present-this-min', label: `${toClock(minStart)} (this min)`, theme: 'present', t: minStart },
                { id: 'present-this-hour', label: `${toClock(hourStart)} (this hour)`, theme: 'present', t: hourStart },
                { id: 'present-this-day', label: `${toDate(dayStart)} (this day)`, theme: 'present', t: dayStart },
                { id: 'present-this-month', label: `${toMonth(monthStart)} (this month)`, theme: 'present', t: monthStart },
                { id: 'present-this-year', label: `${toYear(yearStart)} (this year)`, theme: 'present', t: yearStart }
            ];

            // 2) TRAIL: show 4 previous seconds as a continuum
            const trail = [];
            for (let k = 1; k <= 4; k++) {
                const t = new Date(secStart.getTime() - k * 1000);
                trail.push({
                    id: `present-sec-trail-${k}`,
                    label: toClockSec(t),    // just time; no “last …” text
                    theme: 'present',
                    t
                });
            }

            // map all to render fields
            const items = [anchor, ...main, ...trail].map(e => ({
                ...e,
                year: e.t.getFullYear(),                 // not shown for present in draw
                time_years: yearsBetween(e.t, now)
            }));

            // sort by age ascending: this sec, this min, ..., trail seconds (older lower)
            return items.sort((a, b) => a.time_years - b.time_years);
        }

        // expose for realtime updater
        window.buildPresent = buildPresent;
        const THEME_ORDER_5 = ["kosmos", "biologia", "ihmiskunta", "historia", "moderni teknologia"];

        function decimalYearFromDate(d) {
            const Y = d.getFullYear();
            const a = new Date(Y, 0, 1), b = new Date(Y + 1, 0, 1);
            return Y + (d - a) / (b - a);
        }
        function ageYearsFromISODate(iso, nowMs) {
            const t = Date.parse(iso);
            if (!Number.isFinite(t)) return NaN;
            return (nowMs - t) / (365.2425 * 24 * 3600 * 1000);
        }
        async function prepare() {
            try {
                // 1) Lataa uusi formaatti (meta + flat events)
                const res = await fetch('eventsDB45.json', { cache: 'no-store' });
                if (!res.ok) throw new Error('eventsDB45.json not found');
                const json = await res.json();

                // 2) Lue meta + värit
                const meta = json.meta || {};
                const themeDefs = meta.themes || {};

                // Rakenna themeColors metasta; fallbackit jos väri puuttuu
                const FALLBACK = ["#6372b2", "#70a8c6", "#4b9fa8", "#368d60", "#5a9646"];
                const themeColors = {};
                let i = 0;
                for (const t of Object.keys(themeDefs)) {
                    const c = (themeDefs[t] && themeDefs[t].color) || FALLBACK[Math.min(i, FALLBACK.length - 1)];
                    themeColors[t] = c; i++;
                }

                // 3) Teemajärjestys: ytimet ensin, sitten mahdolliset muut datassa
                const themesInData = Array.from(new Set((json.events || []).map(e => e.theme).filter(Boolean)));
                const themeOrder = THEME_ORDER_5.filter(t => themesInData.includes(t))
                    .concat(themesInData.filter(t => !THEME_ORDER_5.includes(t)));

                // 4) Laske time_years (ikä vuosina) uuteen skaalaan (ei DataUtil.normalizeDataa)
                const now = new Date();
                const nowMs = now.getTime();
                const nowDec = decimalYearFromDate(now);

                const baseEvents = (json.events || []).map(src => {
                    let ageYears = NaN;
                    if (typeof src.year === "number" && Number.isFinite(src.year)) {
                        ageYears = nowDec - src.year; // desimaalivuodesta
                    } else if (typeof src.date === "string") {
                        const t = Date.parse(src.date);
                        if (Number.isFinite(t)) ageYears = (nowMs - t) / (365.2425 * 24 * 3600 * 1000);
                    }
                    // jätä tulevaisuus pois (≤ 0)
                    if (!Number.isFinite(ageYears) || ageYears <= 0) return null;

                    return {
                        theme: src.theme,
                        id: src.id,
                        label: src.label,
                        display_label: src.label, // säilytä mahdolliselle UI-käytölle
                        year: (typeof src.year === "number") ? src.year : undefined,
                        date: (typeof src.date === "string") ? src.date : undefined,
                        time_years: ageYears,
                        author: src.author || "ChatGPT",
                        edit_date: src.edit_date || "2025-10-20",
                        info: src.info,
                        ref: src.ref,
                        language: src.language || meta.language || "fi"
                    };
                }).filter(Boolean)
                    .sort((a, b) => b.time_years - a.time_years);

                // 5) Present-overlayn ankkurit (käytetään jo olemassa olevaa buildPresent()ia)
                const present = buildPresent().sort((a, b) => a.time_years - b.time_years);

                // 6) Yhdistä ja lisää present-teeman väri
                const merged = baseEvents.concat(present);
                const outThemes = Array.from(new Set([...themeOrder, 'present']));
                const outThemeColors = Object.assign({ present: '#ff8c42' }, themeColors);

                // 7) Julkaise timeline.js:lle
                window.TS_DATA = { meta, events: merged, themes: outThemes, themeColors: outThemeColors };
                console.info('[v45.4] TS_DATA prepared:', window.TS_DATA);

            } catch (e) {
                console.warn('[v45.4] prepare() failed, fallback to present-only:', e);
                const present = buildPresent().sort((a, b) => a.time_years - b.time_years);
                window.TS_DATA = { events: present, themes: ['present'], themeColors: { present: '#ff8c42' } };
            }
        }

        // Promise allows timeline.js to wait if needed
        window.TS_DATA_P = prepare();
    })();
</script>

    <script
        src="timeline.js"> // ------------------------------ main rendering module  //
    </script>
    
<script>
    /**
     * Present Overlay (v45.3) — 250 ms updates, aligned to g.root
     * - Attaches under g.root so coordinates match axis/zoom exactly.
     * - Reads major tick exponents (10^n) to map log10(time_years) → y.
     * - No calls to init/zoom/hide → won't steal focus or close InfoBox.
     */

    (function () {
        // ---- time helpers ----
        function toDecimalYear(d) { const Y = d.getFullYear(), a = new Date(Y, 0, 1), b = new Date(Y + 1, 0, 1); return Y + (d - a) / (b - a); }
        function floorToSecond(d) { const x = new Date(d); x.setMilliseconds(0); return x; }
        function floorToMinute(d) { const x = new Date(d); x.setSeconds(0, 0); return x; }
        function floorToHour(d) { const x = new Date(d); x.setMinutes(0, 0, 0); return x; }
        function floorToDay(d) { const x = new Date(d); x.setHours(0, 0, 0, 0); return x; }

        function buildPresent(now = new Date()) {
            const it = [
                { id: 'present-sec', label: 'this second', date: floorToSecond(now) },   // start of this second
                { id: 'present-min', label: 'this minute', date: floorToMinute(now) },   // start of this minute
                { id: 'present-hr', label: 'this hour', date: floorToHour(now) },
                { id: 'present-day', label: 'today', date: floorToDay(now) }
            ].map(e => ({ ...e, decYear: toDecimalYear(e.date) }));
            const MSY = 365.2425 * 24 * 3600 * 1000, nowMs = now.getTime();
            return it.map(e => ({
                ...e,
                yearLabel: e.decYear.toFixed(6),
                // age since the start of the current bin → small near "now" (top)
                time_years: Math.max(1e-10, (nowMs - e.date.getTime()) / MSY)
            }));
        }

        // ---- map log10(time_years) → y, using ticks INSIDE g.root ----
        function getAxisMapping() {
            const ticks = [...document.querySelectorAll('#timeline g.root g.axis g.tick')];
            const pts = [];
            for (const t of ticks) {
                const sup = t.querySelector('tspan:nth-of-type(2)');
                const exp = sup ? parseFloat(sup.textContent) : NaN;
                const tr = t.getAttribute('transform') || '';
                const m = tr.match(/translate\([^,]+,([^)]+)\)/);
                if (Number.isFinite(exp) && m) pts.push({ exp, y: +m[1] }); // y in g.root coords
            }
            if (pts.length < 2) return null;
            const n = pts.length, sx = pts.reduce((s, p) => s + p.exp, 0), sy = pts.reduce((s, p) => s + p.y, 0),
                sxx = pts.reduce((s, p) => s + p.exp * p.exp, 0), sxy = pts.reduce((s, p) => s + p.exp * p.y, 0),
                a = (n * sxy - sx * sy) / (n * sxx - sx * sx), b = (sy - a * sx) / n;
            return v => a * Math.log10(Math.max(1e-12, v)) + b; // y in g.root coords
        }

        // ---- geometry in g.root coords (axis & zoomBar live here) ----
        function axisRight() {
            const axis = document.querySelector('#timeline g.root g.axis');
            if (!axis) return 14;
            try { const r = axis.getBBox(); return r.x + r.width; } catch { return 14; }
        }
        function zoomLeft() {
            const z = document.querySelector('#timeline g.root g.zoomBar .track')
                || document.querySelector('#timeline g.root g.zoomBar');
            if (!z) return 320;
            try { return z.getBBox().x; } catch { return 320; }
        }

        // ---- ensure overlay UNDER g.root (inherits transform automatically) ----
        function ensureOverlay() {
            const root = d3.select('#timeline').select('g.root');
            let g = root.select('#present-overlay');
            if (g.empty()) {
                g = root.append('g')
                    .attr('id', 'present-overlay')
                    .style('pointer-events', 'none'); // never steals input
            }
            return g;
        }

        function render(items) {
            const mapY = getAxisMapping(); if (!mapY) return;
            const x0 = axisRight() + 6, x1 = zoomLeft() - 18, xText = x0 + 10; // all in g.root coords
            const g = ensureOverlay();

            const sel = g.selectAll('g.present-item').data(items, d => d.id);
            const ent = sel.enter().append('g').attr('class', 'present-item').style('opacity', 0);

            ent.append('line')
                .attr('x1', x0).attr('x2', x1).attr('y1', 0).attr('y2', 0)
                .attr('stroke', '#ff8c42').attr('stroke-width', 2)
                .attr('stroke-opacity', 0.9).attr('stroke-dasharray', '2 3');

            ent.append('text')
                .attr('x', xText).attr('y', 0).attr('dy', '0.32em')
                .attr('font-size', 10).attr('fill', '#ffd399')
                .attr('stroke', 'rgba(0,0,0,0.35)').attr('stroke-width', 0.6);

            ent.transition().duration(100).style('opacity', 1);

            sel.merge(ent).each(function (d) {
                const y = mapY(d.time_years);
                d3.select(this).select('line').attr('x1', x0).attr('x2', x1).attr('y1', y).attr('y2', y);
                d3.select(this).select('text').attr('x', xText).attr('y', y).text(`${d.label} (${d.yearLabel})`);
            });

            sel.exit().transition().duration(80).style('opacity', 0).remove();
        }

        document.addEventListener('timeline:ready', () => {
            const tick = () => render(buildPresent(new Date()));
            tick();
            if (window.__presentTimer) clearInterval(window.__presentTimer);
            // UPDATE RATE: 250 ms
            window.__presentTimer = setInterval(tick, 250);
            window.addEventListener('resize', tick, { passive: true });
        });
    })();
</script>

    <script>     // Startup animation: ---------------------------------------------------------------------------
        const nav = performance.getEntriesByType('navigation')[0];
            if (nav && nav.type === 'reload') {
                sessionStorage.removeItem('startup_v41_shown');
            }

        (function(){
            function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // --- Touch cursor helpers (Chrome DevTools -tyylinen pallo) ---
    function ensureTouchCursor(){
                let el = document.getElementById('touch-cursor');
            if(!el){
                el = document.createElement('div');
                el.id = 'touch-cursor';
                // inline style backup (jos style.css puuttuu)
                el.style.cssText = [
                'position:fixed;width:18px;height:18px;border-radius:50%;',
                'background:rgba(255,255,255,0.95);',
                'box-shadow:0 0 0 10px rgba(255,255,255,0.10),0 1px 6px rgba(0,0,0,.35);',
                'z-index:1700;pointer-events:none;opacity:0;',
                'transform:translate(-9px,-9px);',
                'transition:opacity .20s ease,left .60s cubic-bezier(.2,.8,.2,1),top .60s cubic-bezier(.2,.8,.2,1);'
                ].join('');
                document.body.appendChild(el);
            }
        return el;
        }

        function moveTouchCursor(el, x, y, visible=true){
            el.style.left = x + 'px';
        el.style.top  = y + 'px';
        el.style.opacity = visible ? '1' : '0';
        }

        function moveTouchCursorInstant(el, x, y, visible = true) {
                const prev = el.style.transition;
                el.style.transition = 'opacity .20s ease, left 0s, top 0s';
                el.style.left = x + 'px';
                el.style.top = y + 'px';
                el.style.opacity = visible ? '1' : '0';
                void el.offsetWidth; // force layout so it "jumps"
                el.style.transition = prev || 'opacity .20s ease,left .60s cubic-bezier(.2,.8,.2,1),top .60s cubic-bezier(.2,.8,.2,1)';
        }

        function tapRipple(x,y){
            // kevyt "pulse" ilman riippuvuutta ulkoisesta CSS:stä
            const r = document.createElement('div');
                r.style.cssText = [
                'position:fixed;width:28px;height:28px;border-radius:50%;',
                'border:2px solid rgba(255,255,255,0.85);box-shadow:0 0 8px rgba(255,255,255,0.45);',
                'pointer-events:none;z-index:1699;opacity:0.85;',
                'transform:translate(-14px,-14px) scale(0.6);transition:transform .35s ease, opacity .35s ease;'
                ].join('');
                r.style.left = x + 'px';
                r.style.top  = y + 'px';
                document.body.appendChild(r);
            requestAnimationFrame(()=>{
                    r.style.transform = 'translate(-14px,-14px) scale(1.15)';
                r.style.opacity = '0';
            });
            setTimeout(()=>{ if(r.parentNode) r.parentNode.removeChild(r); }, 400);
        }

        function hideTouchCursor(el){
            if(!el) return;
                el.style.opacity = '0';
            setTimeout(()=>{ if(el.parentNode) el.parentNode.removeChild(el); }, 280);
        }

        // Etsi "ihmiskunta" otsikon ruutu-koordinaatti; fallback = TimelineAPI.getCenter()
        function findThemeCenter(theme){
            try{
            const svg = document.getElementById('timeline');
                if(!svg) return null;
                const titles = svg.querySelectorAll('text.card-title');
                for(const t of titles){
                if((t.textContent || '').trim().toLowerCase() === String(theme).toLowerCase()){
                const r = t.getBoundingClientRect();
                return {x: Math.round(r.left + r.width*0.5), y: Math.round(r.top + r.height*0.5) };
                }
            }
            } catch(_){ }
                return null;
        }

        // --- Startup sequence ---
        // Järjestys: tap "ihmiskunta" → 1s tauko → aloita 50px oikealta → zoom in +50% → out −20% → scroll up + down
        async function runStartup(){
        const api = window.TimelineAPI;
        if (!api) return;

        let cursor = ensureTouchCursor();

        // 1) Tap-select "ihmiskunta"
        const cTap = findThemeCenter('ihmiskunta') || api.getCenter();
        moveTouchCursor(cursor, cTap.x, cTap.y, true);
        await sleep(520);
        tapRipple(cTap.x, cTap.y);
        api.selectTheme('ihmiskunta');

        // tauko 1 s (touch irti)
        moveTouchCursor(cursor, cTap.x, cTap.y, false);
        await sleep(1000);

        // uusi aloitus oikean reunan lähelle
        const cont = document.getElementById('timeline-container');
        const r = cont.getBoundingClientRect();
        const start = { x: Math.round(r.left + r.width * 0.5), y: cTap.y };
        // tap + ripple uudessa paikassa → käyttäjälle selkeä vihje "aloita täältä"
        tapRipple(start.x, start.y);
        await sleep(260);

        // tuo "sormi" näkyviin suoraan uuteen kohtaan (ei liukua)
        cursor = ensureTouchCursor();
        moveTouchCursorInstant(cursor, start.x, start.y, true);
        await sleep(180);

        // Zoom (reversed mapping): swipe LEFT = zoom IN, swipe RIGHT = zoom OUT
        const dx = 120;  // swipe distance
        const kIn = 1.5;  // +50%
        const kOut = 0.8;  // −20%

        // zoom in — drag LEFT from start to start - dx, anchor at start
        moveTouchCursor(cursor, start.x - dx, start.y, true);
        api.animScaleBy(kIn, start.x, start.y, 700);
        await sleep(740);

        // zoom out — drag RIGHT back to start, anchor at the left end
        moveTouchCursor(cursor, start.x, start.y, true);
        api.animScaleBy(kOut, start.x - dx, start.y, 560);
        await sleep(600);

        // 3) Scroll: ylös ja alas samasta start-kohdasta
        await sleep(500);
        const dy = -90;
        moveTouchCursor(cursor, start.x, start.y + dy, true);
        api.animTranslateBy(0, dy, 620);
        await sleep(660);

        moveTouchCursor(cursor, start.x, start.y, true);
        api.animTranslateBy(0, -dy, 520);
        await sleep(540);

        hideTouchCursor(cursor);
  }

  // Aja kerran / sessio (ohitus: ?demo=1)
  document.addEventListener('timeline:ready', () => {
    if (matchMedia('(prefers-reduced-motion: reduce)').matches) return;

        const url = new URL(location.href);
        const force = url.searchParams.get('demo') === '1';
        const SS_KEY = 'startup_v41_shown';

        if (!force) {
      if (sessionStorage.getItem(SS_KEY) === '1') return;
        sessionStorage.setItem(SS_KEY, '1');
    }
        setTimeout(runStartup, 380);
        const infoToggle = document.getElementById('info-toggle');
      const infoBox = document.getElementById('info-box');

      if (infoToggle && infoBox) {
          infoToggle.addEventListener('click', async (e) => {
              // Intercept only the first click on "?" so our sequence runs first.
              e.preventDefault();
              e.stopPropagation();

              // Play the same startup animation regardless of session flag
              await runStartup();

              // Open the info box after animation
              infoBox.hidden = false;
              infoBox.style.display = 'block';
          }, { capture: true, once: true });
      }

  });
})();
</script>

</body>

</html>