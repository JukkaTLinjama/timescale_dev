<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
        <title>History Timeline v46.2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link rel="stylesheet" href="style.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <h1 id="page-title">
        History at your fingertips — Big Bang to 2025
        <span style="font-size:0.65em; color:#9e9d9d;">v46.2</span>
    </h1>

    <div id="info-toggle">?</div>
<div id="info-box" style="display:none;">
    <div id="help-message">
        <p><em>Experimental visualization</em> of history across an immense time span.</p>
        <p>A vertical, <em>zoomable logarithmic timeline</em> of key events from the Big Bang to the present
            (2025).</p>
        <p>Events are grouped into <em>partly overlapping themes</em> that you can bring to the front.</p>

        <hr style="border:none; border-top:1px solid #ddd; margin:8px 0;">
        <!-- pikavinkit -->
        <p><em>Tips:</em> Pinch/scroll content or swipe L/R to zoom · Click a theme card to focus · Tap an event
            for notes</p>
    </div>

    <!-- status päivittyy skriptistä -->
    <div id="status-message" style="font-size:0.75em; color:#666; margin-top:2px;">
        Loading…
    </div>

    <!-- erillinen author-kenttä, EI muutu skriptissä -->
    <div id="author" style="font-size:0.75em; color:#666; margin-top:6px;">
        Authors: Jukka Linjama &amp; ChatGPT 5.0. 
    </div>

    <div id="license-info" style="font-size:0.7em; color:#666; margin-top:6px;">
        Project in <a href="https://github.com/JukkaTLinjama/log-aikajana" target="_blank">Github</a>
        Shared as an <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>
        experiment.<br>
        Enjoy &amp; share!
    </div>
</div>

    <div id="timeline-container">
        <svg id="timeline"></svg>
    </div>

    <div id="page-footer">© 2025 JL · CC BY 4.0</div>

    <script>
        // Debug switch via ?debug=1
        (function () {
            const u = new URL(location.href);
            const dbg = u.searchParams.get("debug") === "1";
            // näkyvä pieni virhepalkki vain debug-tilassa
            if (dbg) {
                const bar = document.createElement("div");
                bar.id = "debug-bar";
                bar.style.cssText = "position:fixed;left:0;right:0;bottom:0;z-index:99999;font:12px/1.4 system-ui;padding:6px 10px;background:#300;color:#fdd;display:none";
                bar.textContent = "Debug on. Errors will appear here.";
                document.addEventListener("DOMContentLoaded", () => document.body.appendChild(bar));
                window.__DBG__ = true;
                window.addEventListener("error", (e) => {
                    bar.style.display = "block";
                    bar.textContent = "Error: " + (e.message || "unknown");
                    console.error("[timeline:error]", e.message, e.error);
                });
                window.addEventListener("unhandledrejection", (e) => {
                    bar.style.display = "block";
                    bar.textContent = "Promise error: " + (e.reason && (e.reason.message || e.reason));
                    console.error("[timeline:promise]", e.reason);
                });
                console.log("%c[debug] enabled", "color:#9f9");
            }
        })();
    </script>

    <!-- Lightweight helpers (no side effects). Loaded before timeline.js -->
    <script>
        (function () {
            if (window.Util) return; // avoid double-load
            const Util = {};

            /** Try/catch wrapper for draw/layout functions. */
            Util.safe = function safe(fn, label) {
                try { return (typeof fn === "function") ? fn() : undefined; }
                catch (err) {
                    const msg = `[${label}] ${err && err.message ? err.message : err}`;
                    console.error("[timeline:render]", label, err);
                    const bar = document.getElementById("debug-bar");
                    if (bar) { bar.style.display = "block"; bar.textContent = "Render error: " + msg; }
                }
            };

            /** Debounce helper. */
            Util.debounce = function debounce(fn, ms) {
                let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
            };

            /** Perf timer: logs only when debug (?debug=1) is on. */
            Util.timed = function timed(label, fn) {
                const t0 = performance.now();
                const out = fn();
                const t1 = performance.now();
                if (window.__DBG__) console.log(`[perf] ${label}: ${(t1 - t0).toFixed(1)} ms`);
                return out;
            };

            /** Clamp helper. */
            Util.clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

            Util.textHaloOffset = function (yEvt, yFoc) {
                const R = 40, MAX = 8;
                const dy = yEvt - yFoc, ady = Math.abs(dy);
                if (ady === 0 || ady >= R) return 0;
                const t = 1 - ady / R;
                return Math.sign(dy) * MAX * Math.pow(t, 1.0);
            };
            // ---------------- Card text helpers (pure, DOM-free) ----------------

            /** Preferred display label for an event (falls back to 'label'). */
            Util.eventLabel = function (ev) {
                return (ev?.display_label || ev?.label || '').toString();
            };

            /** One-line meta string (e.g., year + theme if present). */
            Util.eventMeta = function (ev) {
                // Prefer preformatted "when" text (Finnish), then "ago", then raw year.
                const when = (ev?.display_when || ev?.display_ago || (ev?.year ?? '').toString());
                const theme = ev?.theme ? `Theme: ${ev.theme}` : null; // keep label in English for now
                return [when, theme].filter(Boolean).join(' · ');
            };
            // Build the event title text for labels on the timeline.
            // Uses precomputed display_when/display_ago; falls back to plain label.
            // Never shows empty parentheses.
            Util.eventTitle = function (ev) {
                const base = Util.eventLabel(ev);
                const when = (ev?.display_when || ev?.display_ago || '').toString().trim();
                return when ? `${base} (${when})` : base;
            };
            // Build short event title for on-chart labels: use ONLY relative time.
            // Never shows empty parentheses.
            Util.eventTitleShort = function (ev) {
                const base = Util.eventLabel(ev);
                const ago = (ev?.display_ago || '').toString().trim();
                return ago ? `${base} (${ago})` : base;
            };

            /** Safe truncation with ellipsis; avoids breaking short strings. */
            Util.truncate = function (str, max = 60, suffix = '…') {
                const s = (str ?? '').toString();
                if (max <= 0) return '';
                if (s.length <= max) return s;
                // preserve word boundary if possible
                const cut = s.slice(0, max - suffix.length);
                const ws = cut.lastIndexOf(' ');
                return (ws >= 24 ? cut.slice(0, ws) : cut) + suffix;
            };
            // --- Card metrics (pure, DOM-free except bbox reads) ---
            // Computes paddings and rect based on measured text heights.
            Util.cardMetrics = function (titleSel, groupSel, yTopEv, yBotEv, viewH) {
                const titleH = Math.ceil((() => { try { return titleSel.node().getBBox().height; } catch { return 10; } })()) || 10;
                const tmp = groupSel.append("text").attr("class", "event-label").attr("visibility", "hidden").text("X");
                const evH = Math.ceil((() => { try { return tmp.node().getBBox().height; } catch { return 9; } })()) || 9;
                tmp.remove();

                const topPad = titleH + 6;
                const botPad = Math.ceil(evH * 2.2) + 8;
                const yRect = Math.min(yTopEv, yBotEv) - topPad;
                const hRect = Math.abs(yBotEv - yTopEv) + topPad + botPad;

                const fullyAbove = (yRect + hRect) < 15;
                const fullyBelow = yRect > viewH;

                return { topPad, botPad, yRect, hRect, fullyAbove, fullyBelow };
            };

            window.Util = Util;
        })();
    </script>
    <script>
        // -----------------------------------------------------------
        // TS_CFG / TS_DELAY
        // Global configuration objects used by timeline.js
        // Keep them here so values are easy to tweak without touching JS files.
        // -----------------------------------------------------------
        window.TS_CFG = {
            // Margins for the timeline viewport (pixels)
            margin: { top: 12, right: 54, bottom: 12, left: 54 },

            // Right-side zoom bar dimensions
            zoomBar: { width: 22, gap: 10 },

            // Event card layout parameters
            card: { minW: 160, pad: 10 },

            // Color palette used for event themes
            palette: ["#6372b2ff", "#70a8c6", "#4b9fa8", "#368d60ff", "#5a9646ff"],

            // Prefocus halo behavior (for focus highlight transitions)
            prefocus: { radiusPx: 16, hysteresisPx: 8 }
        };

        // Global timing delays for UI interactions (ms)
        window.TS_DELAY = { ACTIVATE: 1000, ZOOM: 1500 };
    </script>

    <script>
        // -----------------------------------------------------------
        // InfoBox module
        // Handles the small popup panel showing detailed info about an event.
        // Encapsulated in an IIFE so it doesn't leak global variables.
        // Accessible through window.InfoBox.show(event, screenBox)
        // and window.InfoBox.hide().
        // -----------------------------------------------------------
        (function () {
            const infoCfg = { margin: 10 };  // minimal distance from window edges (px)
            let infoEl = null;               // singleton DOM element for the popup
            // --- User intent tracking to keep the InfoBox persistent during programmatic refreshes ---
            // We only allow hiding the tooltip shortly after a *trusted* user action (click, wheel, key, touch).
            // All other (programmatic) calls to hide() will be ignored.
            // This fixes the "tooltip disappears every second" issue without touching timeline.js.
            let __lastUserIntentTs = 0;
            const __USER_INTENT_WINDOW_MS = 1200;

            // Capture trusted user interactions very early in the event flow.
            ['pointerdown', 'wheel', 'keydown', 'touchstart'].forEach((type) => {
                window.addEventListener(type, (e) => {
                    if (e && e.isTrusted) {
                        __lastUserIntentTs = performance.now();
                    }
                }, { capture: true, passive: true });
            });

            // Ensure the info box element exists (lazy creation)
            function ensureInfoEl() {
                if (infoEl && infoEl.parentNode) return infoEl;
                infoEl = document.createElement('div');
                infoEl.id = 'event-info';
                document.body.appendChild(infoEl);
                // Prevent clicks inside the box from bubbling (so it doesn’t close)
                infoEl.addEventListener('click', e => e.stopPropagation());
                return infoEl;
            }
            // Build inner HTML structure for the info popup based on event data
            function buildEventHTML(ev) {
                const label = ev?.display_label || ev?.label || 'Event';
                // Prefer the precomputed Finnish "when" text
                const when = (ev?.display_when || ev?.display_ago || (ev?.year ?? '').toString());
                const meta = [when, ev?.theme ? `Theme: ${ev.theme}` : null]
                    .filter(Boolean)
                    .join(' · ');

                // Prefer localized comments prepared by DataUtil; fallback to raw comments
                const comments = (typeof ev?.display_comments === 'string' && ev.display_comments.trim().length > 0)
                    ? ev.display_comments.trim()
                    : ((typeof ev?.comments === 'string') ? ev.comments.trim() : '');

                // Optional reference/link (keep current behavior)
                const ref = (ev?.ref || '').trim();
                const link = ref && /^https?:\/\//i.test(ref)
                    ? `<div class="hint">Ref: <a href="${ref}" target="_blank" rel="noopener">link</a></div>`
                    : (ref ? `<div class="hint">Ref: ${ref}</div>` : ``);

                const body = comments
                    ? `<div class="body">${comments}</div>`
                    : `<div class="body" style="opacity:.8;">(No notes)</div>`;

                return `
                    <div class="title">${label}</div>
                    <div class="meta">${meta}</div>
                    ${body}${link}
                    <div class="hint">Tip: click outside to close.</div>
                    `;
            }

            // Show the info box at a screen position derived from the event’s bounding box
            function show(ev, screenBox) {
                // Opening the InfoBox should not be followed by an immediate auto-hide.
                // Reset user-intent timestamp so programmatic refreshes won't close it.
                __lastUserIntentTs = 0;

                const el = ensureInfoEl();
                el.innerHTML = buildEventHTML(ev);
                el.classList.remove('is-visible');
                // Initial hidden state for animation (fade + small scale)
                el.style.visibility = 'hidden';
                el.style.opacity = '0';
                el.style.transform = 'translateY(6px) scale(0.98)';

                requestAnimationFrame(() => {
                    const rect = el.getBoundingClientRect();
                    const M = infoCfg.margin;
                    let x = Math.round(screenBox.left + 12);
                    let y = Math.round(screenBox.top - rect.height - 8);

                    // If it would go offscreen above, move below the event instead
                    if (y < M) y = Math.round(screenBox.bottom + 8);
                    // Clamp to right and bottom edges
                    if (x + rect.width + M > innerWidth)
                        x = Math.max(M, innerWidth - rect.width - M);
                    if (y + rect.height + M > innerHeight)
                        y = Math.max(M, innerHeight - rect.height - M);

                    el.style.left = `${x}px`;
                    el.style.top = `${y}px`;

                    // Trigger CSS transition to visible state
                    requestAnimationFrame(() => {
                        el.style.visibility = '';
                        el.style.opacity = '';
                        el.style.transform = '';
                        el.classList.add('is-visible');
                    });
                });
            }

            // Hide the info box (simply remove visible class)
            function hide() {
                // Allow hiding only if there was a trusted user action very recently.
                // This prevents auto-refresh (programmatic) code paths from closing the InfoBox.
                const now = performance.now();
                const userAllowed = (now - __lastUserIntentTs) <= __USER_INTENT_WINDOW_MS;

                if (!userAllowed) {
                    // Ignore programmatic hide() calls (e.g., 1-second refresh)
                    return;
                }

                const el = ensureInfoEl();
                el.classList.remove('is-visible');
            }

            // Close on click outside or Escape key
            document.addEventListener('click', hide);
            document.addEventListener('keydown', e => { if (e.key === 'Escape') hide(); });

            // Expose public API
            window.InfoBox = { show, hide };
        })();
    </script>

    <script>
        // -----------------------------------------------
        // SwipeZoom module: handles touch and mouse gestures for zooming and panning
        // Horizontal swipe in center area → zoom in/out
        // Vertical swipe outside center area → pan up/down
        // This replaces the old setupGlobalSwipeZoom() in timeline.js
        // -----------------------------------------------
        (function () {
            /**
             * Attach gesture handling to an SVG element.
             * @param {d3.Selection} svgSel - the d3 selection for main SVG
             * @param {d3.ZoomBehavior} zoomBehavior - the D3 zoom behavior already created
             * @param {object} opts - optional parameters
             *   innerHeight: function returning window height (used to detect center zone)
             */
            function attach(svgSel, zoomBehavior, opts) {
                const innerHeight = (opts && opts.innerHeight) || (() => window.innerHeight);

                // --- gesture tuning constants ---
                const DEAD = 3;              // minimal movement before mode is decided
                const DOM_RATIO = 1.5;       // horizontal dominance threshold
                const SENS_TOUCH = -0.006;   // zoom sensitivity for touch
                const SENS_MOUSE = -0.003;   // zoom sensitivity for mouse
                const STEP = 20;             // max delta per frame
                const CLAMP_MIN = 0.95;      // minimal scale per step
                const CLAMP_MAX = 1.05;      // maximal scale per step

                // --- internal state ---
                let active = false;          // pointer currently down
                let mode = null;             // 'zoom' | 'pan' | null
                let startX = 0, startY = 0, lastX = 0, lastY = 0;
                let startInCenter = false;     // did gesture start in center zone?

                // --- helper: check if pointer Y is within the central zoom zone ---
                function inCenterZone(y) {
                    const H = innerHeight();
                    const zoneH = Math.max(80, Math.min(H * 0.36, 160)); // 80–160px or ~1/3 screen
                    const y0 = (H - zoneH) / 2, y1 = y0 + zoneH;
                    return y >= y0 && y <= y1;
                }

                const isTouch = (e) => e.pointerType === 'touch';
                const svgNode = svgSel.node();
                const contEl = document.getElementById('timeline-container');

                // --- visual feedback class toggle ---
                function setGestureActive(on) {
                    if (on) {
                        svgNode.classList.add('gesture-active');
                        if (contEl) contEl.classList.add('gesture-active');
                    } else {
                        svgNode.classList.remove('gesture-active');
                        if (contEl) contEl.classList.remove('gesture-active');
                    }
                }

                // -----------------------------------------------
                // pointerdown → start tracking
                // -----------------------------------------------
                svgNode.addEventListener('pointerdown', (e) => {
                    if (!e.isPrimary) return;        // ignore secondary touches
                    active = true; mode = null;
                    startX = lastX = e.clientX;
                    startY = lastY = e.clientY;
                    startInCenter = inCenterZone(e.clientY);
                    try { e.target.setPointerCapture(e.pointerId); } catch { }
                    e.stopPropagation();
                }, { passive: true, capture: true });

                // -----------------------------------------------
                // pointermove → decide mode and perform zoom/pan
                // -----------------------------------------------
                svgNode.addEventListener('pointermove', (e) => {
                    if (!active || !e.isPrimary) return;
                    const dxTot = e.clientX - startX;
                    const dyTot = e.clientY - startY;

                    // --- determine mode when movement passes threshold ---
                    if (mode === null && (Math.abs(dxTot) >= DEAD || Math.abs(dyTot) >= DEAD)) {
                        const horizDominates = (Math.abs(dxTot) > Math.abs(dyTot) * DOM_RATIO);
                        mode = (horizDominates && startInCenter) ? 'zoom' : 'pan';
                        setGestureActive(true);
                    }

                    // --- zoom mode ---
                    if (mode === 'zoom') {
                        const dxStep = Math.max(-STEP, Math.min(STEP, e.clientX - lastX));
                        if (Math.abs(dxStep) >= DEAD) {
                            lastX = e.clientX;
                            const sens = isTouch(e) ? SENS_TOUCH : SENS_MOUSE;
                            const factor = Math.max(CLAMP_MIN, Math.min(CLAMP_MAX, 1 + dxStep * sens));
                            // D3 handles scaling relative to pointer position
                            svgSel.call(zoomBehavior.scaleBy, factor, [e.clientX, e.clientY]);
                        }
                        e.stopPropagation();
                        return;
                    }

                    // --- pan mode ---
                    if (mode === 'pan') {
                        const dyStep = Math.max(-STEP, Math.min(STEP, e.clientY - lastY));
                        if (Math.abs(dyStep) >= DEAD) {
                            lastY = e.clientY;
                            svgSel.call(zoomBehavior.translateBy, 0, dyStep);
                        }
                        e.stopPropagation();
                        return;
                    }

                    e.stopPropagation();
                }, { passive: true, capture: true });

                // -----------------------------------------------
                // pointerup / cancel / lostcapture → reset
                // -----------------------------------------------
                const end = () => {
                    active = false; mode = null;
                    setGestureActive(false);
                };
                svgNode.addEventListener('pointerup', end, { passive: true, capture: true });
                svgNode.addEventListener('pointercancel', end, { passive: true, capture: true });
                svgNode.addEventListener('lostpointercapture', end, { passive: true, capture: true });
            }

            // Expose globally for timeline.js
            window.SwipeZoom = { attach };
        })();
    </script>
    <script>
        // -------------------------------------------------------
        // Ticks: compute major/minor tick values for a log domain
        // - majors: 10^n within [d0, d1]
        // - minors: 2..9 × 10^n within [d0, d1] (optional)
        // Keep this pure (no DOM), so it's easy to move to utils.js later.
        // -------------------------------------------------------
       (function () {
            // Stable decade ticks on zoom/pan:
            // - lower bound uses CEIL (push up to the next full decade)
            // - upper bound uses FLOOR (down to the previous full decade)
            // - tiny EPS avoids floating jitter exactly on boundaries (e.g. 1e-8 ± 1e-16)
            const EPS = 1e-12;

            function majorsFromDomain(d0, d1) {
                if (d0 > d1) [d0, d1] = [d1, d0];

                // guard against zeros/negatives in log scale
                d0 = Math.max(d0, Number.MIN_VALUE);
                d1 = Math.max(d1, d0);

                const n0 = Math.ceil(Math.log10(d0 * (1 + EPS)));
                const n1 = Math.floor(Math.log10(d1 * (1 - EPS)));

                const values = [];
                const exponents = [];
                for (let e = n0; e <= n1; e++) {
                    values.push(Math.pow(10, e));
                    exponents.push(e);
                }
                return { exponents, values };
            }

            function minorsFromDomain(d0, d1, showMinor) {
                if (!showMinor) return [];
                if (d0 > d1) [d0, d1] = [d1, d0];

                d0 = Math.max(d0, Number.MIN_VALUE);
                d1 = Math.max(d1, d0);

                const n0 = Math.ceil(Math.log10(d0 * (1 + EPS)));
                const n1 = Math.floor(Math.log10(d1 * (1 - EPS)));

                const out = [];
                for (let e = n0; e <= n1; e++) {
                    const base = Math.pow(10, e);
                    for (let m = 2; m <= 9; m++) {
                        const v = m * base;
                        if (v >= d0 && v <= d1) out.push(v);
                    }
                }
                return out;
            }

            window.Ticks = { majorsFromDomain, minorsFromDomain };
        })();

    </script>
    <script>
        // -------------------------------------------------------
        // CenterBand: pure math for the center zone geometry
        // Computes the vertical center line (midY), the zoom zone band (zoneY/zoneH),
        // and the horizontal endpoints (xLeft/xRight) for the center hairline.
        // Inputs are plain numbers; no DOM access here to keep it reusable.
        // -------------------------------------------------------
        (function () {
            /**
             * Compute geometry for the center band and hairline.
             * @param {number} w - svg width (outer)
             * @param {number} h - svg height (outer)
             * @param {number|NaN} axisRight - right edge (px) of the axis group, or NaN if unknown
             * @param {number|NaN} zoomBarLeft - left edge (px) of the zoom bar/track, or NaN if unknown
             * @returns {{zoneY:number, zoneH:number, midY:number, xLeft:number, xRight:number}}
             */
            function compute(w, h, axisRight, zoomBarLeft) {
                // Vertical band in the middle of the screen (used as "zoom allowed" zone)
                const zoneH = Math.max(80, Math.min(h * 0.36, 160)); // clamp 80–160 px
                const zoneY = (h - zoneH) / 2;
                const midY = Math.round(h / 2);

                // Horizontal endpoints: keep the hairline clear of axis and zoom bar
                const DEFAULT_LEFT_INSET = 14; // fallback padding from the left edge
                const DEFAULT_RIGHT_INSET = 4;  // fallback padding from the right edge
                const AXIS_GAP = 1;            // extra space after axis
                const ZOOMB_GAP = 15;           // extra space before zoom bar

                // Build endpoints with sensible fallbacks
                let xLeft = Number.isFinite(axisRight) ? Math.ceil(axisRight + AXIS_GAP) : DEFAULT_LEFT_INSET;
                let xRight = Number.isFinite(zoomBarLeft) ? Math.floor(zoomBarLeft - ZOOMB_GAP) : (w - DEFAULT_RIGHT_INSET);

                // Clamp to viewport
                xLeft = Math.max(0, Math.min(xLeft, w - DEFAULT_RIGHT_INSET));
                xRight = Math.max(DEFAULT_LEFT_INSET, Math.min(xRight, w));

                // If span is too short, relax a bit but stay reasonable
                const span = xRight - xLeft;
                if (span < w * 0.3) {
                    const leftRelax = Number.isFinite(axisRight) ? Math.min(axisRight + AXIS_GAP, 40) : 0;
                    const rightRelax = Number.isFinite(zoomBarLeft) ? Math.min((w - zoomBarLeft) + ZOOMB_GAP, 40) : 0;
                    xLeft = DEFAULT_LEFT_INSET + leftRelax;
                    xRight = w - DEFAULT_RIGHT_INSET - rightRelax;
                }

                // Final safety: ensure at least a minimal centered segment
                if ((xRight - xLeft) < 24) {
                    const cx = Math.round(w / 2);
                    xLeft = cx - 12;
                    xRight = cx + 12;
                }

                return { zoneY, zoneH, midY, xLeft, xRight };
            }

            // Expose as a tiny module
            window.CenterBand = { compute };
        })();
    </script>
<script>
    // -------------------------------------------------------
    // DataUtil: normalizeData()
    // Preprocesses loaded eventsDB.json:
    //  - merges group.theme into each event
    //  - applies i18n labels for the chosen language (from metadata.locale_default)
    //  - extracts theme order and colors from metadata.ui
    // -------------------------------------------------------
    (function () {
        function normalizeData(data, langFromCaller) {
            // Read from 'metadata' (the actual key in eventsDB.json)
            const meta = data.metadata || {};
            const ui = meta.ui || {};
            const themeOrder = Array.isArray(ui.themeOrder) ? ui.themeOrder : null;
            const themeColors = ui.themeColors || null;

            // Choose language: caller can pass one, otherwise use metadata.locale_default
            const lang = langFromCaller || meta.locale_default || "fi";

            // Flatten groups → inject theme into each event and build display_label/comments
            const events = (data.events || []).flatMap(g =>
                (g.events || []).map(e => ({
                    ...e,
                    theme: g.theme,
                    display_label:
                        (e.i18n && e.i18n[lang] && e.i18n[lang].label)
                            ? e.i18n[lang].label
                            : e.label,
                    display_comments:
                        (e.i18n && e.i18n[lang] && e.i18n[lang].comments)
                            ? e.i18n[lang].comments
                            : (e.comments || "")
                }))
            );

            // Derive themes, respecting metadata.ui.themeOrder when present
            const themes = themeOrder
                ? themeOrder.filter(t => events.some(e => e.theme === t))
                : Array.from(new Set(events.map(e => e.theme)));

            return { events, themes, themeColors, langUsed: lang };
        }

        // Expose globally for timeline.js
        window.DataUtil = { normalizeData };
    })();
</script>
<script>
    /* ----------------------------------------------------------
       v45.1 — Data preparation and absolute "present" events
       ----------------------------------------------------------
       This script moves data loading from timeline.js to index.html.
       It:
       1. Fetches eventsDB.json and metadata.
       2. Normalizes via DataUtil.normalizeData (already loaded).
       3. Anchors "present" events to the real wall clock time.
       4. Exposes the combined data as window.TS_DATA for timeline.js.
       ---------------------------------------------------------- */

    (function () {
        /* --- Time utilities (candidates for utils/timeUtils.js) --- */

        const YEAR_MS = 365.2425 * 24 * 3600 * 1000;
        const yearsBetween = (a, b) => Math.abs(b - a) / YEAR_MS;

        const floorToSecond = d => (d = new Date(d), d.setMilliseconds(0), d);
        const floorToMinute = d => (d = new Date(d), d.setSeconds(0, 0), d);
        const floorToHour = d => (d = new Date(d), d.setMinutes(0, 0, 0), d);
        const floorToDay = d => (d = new Date(d), d.setHours(0, 0, 0, 0), d);

      /* --- Build present anchors (stable header + trailing seconds + fixed intervals) --- */
        function buildPresent(now = new Date()) {
            const MSY = 31557600 * 1000;      // ms per tropical year
            const SEC_TO_YEARS = 1 / 31557600;
            const THIS_SEC_EPS = SEC_TO_YEARS * 0.02;   // ~20 ms safety gap
            const USE_FIXED_ONE_SEC = true;

            const items = [];

            // --- helpers ---
            const tNowRaw = Date.now();
            // Quantize to whole seconds so multiple refresh paths (1 Hz + render) see identical “now”
            const tNow = Math.floor(tNowRaw / 1000) * 1000;

            const withinSec = (tNow % 1000) / 1000;
            const thisSecAgeSec = USE_FIXED_ONE_SEC ? 1.0 : Math.max(0.1, withinSec);
            const thisSecYears = thisSecAgeSec * SEC_TO_YEARS;

            // --- small reference anchors ---
            const REF_0_1S_YEARS = 0.1 * SEC_TO_YEARS;
            const ONE_MIN_YEARS = 60 * SEC_TO_YEARS;
            const ONE_HOUR_YEARS = 3600 * SEC_TO_YEARS;
            const ONE_DAY_YEARS = 86400 * SEC_TO_YEARS;
            const ONE_MONTH_YEARS = 1 / 12;
            const ONE_YEAR_YEARS = 1;

            // helper for label text  (formats nicely)
            function fmtAgo(secs) {
                if (secs < 1) return `${secs.toFixed(1)} s ago`;
                if (secs < 60) return `${secs.toFixed(0)} s ago`;
                if (secs < 3600) return `${(secs / 60).toFixed(0)} min ago`;
                if (secs < 86400) return `${(secs / 3600).toFixed(0)} h ago`;
                if (secs < 2592000) return `${(secs / 86400).toFixed(0)} d ago`;
                if (secs < 31557600) return `${(secs / 2592000).toFixed(0)} mo ago`;
                return `${(secs / 31557600).toFixed(0)} y ago`;
            }

            // ─────────────────────────────────────────────
            // 1) "this sec" shows next clock second, labeled "(time 1 s ago)"
            const nextDate = new Date(now.getTime() + 1000); // +1 second ahead
            const nextTime = nextDate.toTimeString().slice(0, 8);
            items.push({
                theme: 'present',
                label: `${nextTime} (time 1 s ago)`,
                time_years: thisSecYears
            });

            // ─────────────────────────────────────────────
            // 2) short reference (0.1 s ago) — place slightly *above* “this sec”
            items.push({
                theme: 'present',
                label: fmtAgo(0.1),
                time_years: Math.min(thisSecYears - THIS_SEC_EPS, REF_0_1S_YEARS)
            });

            // ─────────────────────────────────────────────
            // 3) Deterministic trail from a single post-load 5 s anchor (no per-marker state)

            // 3.1) asetetaan pysyvä ensimmäinen 5 s raja: vasta sivulatauksen JÄLKEINEN raja
            if (typeof window.__first5sAnchorMs === 'undefined') {
                const bucketAtLoad = Math.floor(tNow / 5000);
                const bucketNow = Math.floor(tNow / 5000);
                // Ei vielä luoda ankkuria; odotetaan että ylitetään seuraava 5 s -raja
                window.__first5sAnchorMs = null;
                window.__first5sLoadBucket = bucketAtLoad;
            }
            // jos rajaa ei vielä ole ja on ylitetty seuraava 5 s -bucket, lukitaan se
            if (window.__first5sAnchorMs === null) {
                const bucketNow = Math.floor(tNow / 5000);
                if (bucketNow > window.__first5sLoadBucket) {
                    window.__first5sAnchorMs = bucketNow * 5000; // täsmälleen …:50/…:55/…:00/…
                }
            }

            const firstAnchor = window.__first5sAnchorMs;

            if (typeof firstAnchor === 'number') {
                // 3.2) lasketaan kaikki 5 s -ankkurit välillä [firstAnchor, tNow]
                // i = 0 on ensimmäinen ankkuri, i kasvaa yhdellä jokaisesta 5 s rajasta
                const n = Math.floor((tNow - firstAnchor) / 5000); // 0..N
                for (let i = 0; i <= n; i++) {
                    const anchor = firstAnchor + i * 5000;  // tämän markkerin syntyhetki (5 s raja)

                    // markkerin ikä: alkaa 2 s:sta ja kasvaa 1 s/s
                    const ageSec = 2 + (tNow - anchor) / 1000;

                    // Integroitunut ikä (kokonaisluvuksi), käyttöön vain näkyvyyskriteeriin
                    const ageInt = Math.floor(ageSec + 1e-9);

                    // 3.3) näkyvyys/kuolema:
                    //  - näytä kaikki kun ikä < 15 s
                    //  - 15–45 s: näytä tasan 15:n monikerrat (15, 30)
                    //  - ≥ 45 s: älä näytä mitään
                    if (ageInt >= 45) continue;
                    if (ageInt < 45 && (ageInt < 15 || ageInt % 15 === 0)) { /* näkyvä */ }
                    else continue;

                    // 3.4) labelin kellonaika on syntyankkuri (…:50/…:55/…:00/…), "ago" on ageInt
                    const labelStr = new Date(anchor).toTimeString().slice(0, 8);

                    items.push({
                        theme: 'present',
                        label: `${labelStr} (${fmtAgo(ageInt)})`,
                        // sijainti käyttää jatkuvaa aikaa; pieni ε pitää sen “this sec” -viivan alla
                        time_years: Math.max(thisSecYears + THIS_SEC_EPS, ageSec * SEC_TO_YEARS)
                    });
                    // DEBUG (poista kun ok):  console.log('trail', { i, anchor, ageSec: ageSec.toFixed(2), ageInt });
                }
            }

            // ─────────────────────────────────────────────
            // 4) fixed larger intervals
            const FIXED = [
                { secs: 60, years: ONE_MIN_YEARS },
                { secs: 3600, years: ONE_HOUR_YEARS },
                { secs: 86400, years: ONE_DAY_YEARS },
                { secs: 2592000, years: ONE_MONTH_YEARS },
                { secs: 31557600, years: ONE_YEAR_YEARS }
            ];
            for (const f of FIXED) {
                items.push({
                    theme: 'present',
                    label: fmtAgo(f.secs),
                    time_years: Math.max(thisSecYears + THIS_SEC_EPS, f.years)
                });
            }

            // ensure chronological order (newest → oldest)
            items.sort((a, b) => a.time_years - b.time_years);
            return items;
        }

        // expose for realtime updater
        window.buildPresent = buildPresent;
        const THEME_ORDER_5 = ["kosmos", "biologia", "ihmiskunta", "historia", "moderni teknologia"];

        function decimalYearFromDate(d) {
            const Y = d.getFullYear();
            const a = new Date(Y, 0, 1), b = new Date(Y + 1, 0, 1);
            return Y + (d - a) / (b - a);
        }
        function ageYearsFromISODate(iso, nowMs) {
            const t = Date.parse(iso);
            if (!Number.isFinite(t)) return NaN;
            return (nowMs - t) / (365.2425 * 24 * 3600 * 1000);
        }
                // --- Finnish "ago" formatter for display fields (no DB changes) ---
        // Converts age in years -> human readable "ago" text + unit selection.
        function formatAgoFi(ageYears) {
            const y = Math.max(0, +ageYears || 0); // guard

            const SEC_PER_YEAR = 31557600;
            const s = y * SEC_PER_YEAR;

            // sub-year ranges by natural units
            if (s < 90) {
                const n = Math.round(s);
                return { value: n, unit: 's', text: `${n} s sitten` };
            }
            if (s < 90 * 60) {
                const n = Math.round(s / 60);
                return { value: n, unit: 'min', text: `${n} min sitten` };
            }
            if (s < 36 * 3600) {
                const n = Math.round(s / 3600);
                return { value: n, unit: 'h', text: `${n} h sitten` };
            }
            if (s < 90 * 86400) {
                const n = Math.round(s / 86400);
                return { value: n, unit: 'd', text: `${n} d sitten` };
            }
            if (y < 1.5) {
                const n = Math.round(y * 12);
                return { value: n, unit: 'kk', text: `${n} kk sitten` };
            }
            if (y < 950) {
                const n = Math.round(y);
                return { value: n, unit: 'v', text: `${n} v sitten` };
            }
            if (y < 950_000) {
                const n = Math.round(y / 1_000);
                // Optionally "ka" for abbreviated scientific style; we keep plain Finnish.
                return { value: n, unit: 'tuhat v', text: `${n} t. v sitten` };
            }
            if (y < 950_000_000) {
                const raw = y / 1_000_000;
                const n = (raw < 10) ? Math.round(raw * 10) / 10 : Math.round(raw);
                return { value: n, unit: 'milj. v', text: `${n} milj. v sitten` };
            }
            // billions of years
            const raw = y / 1_000_000_000;
            const n = (raw < 10) ? Math.round(raw * 10) / 10 : Math.round(raw);
            return { value: n, unit: 'mrd v', text: `${n} mrd v sitten` };
        }
        // --- Robust year parser (handles number or string; tolerates BCE/eaa forms) ---
        // Accepts: 2020, "2020", "-27", "−27", "27 BCE", "27 eaa", "563 eKr", etc.
        // Returns: finite Number (negative for BCE) or NaN if not parseable.
        function parseYearFlexible(y) {
            if (typeof y === "number" && Number.isFinite(y)) return y;
            if (typeof y !== "string") return NaN;

            let s = y.trim().toLowerCase();

            // Normalize Unicode minus/en dash to ASCII hyphen
            s = s.replace(/[\u2212\u2013\u2014]/g, "-");

            // Detect BCE markers in Finnish/English and flip sign if needed
            // (eaa = "ennen ajanlaskun alkua"; e.kr. variants; bce)
            const hasBce = /\b(eaa|e\.?kr|bce)\b/.test(s);

            // Remove non-digit markers/words (keep sign and digits)
            // e.g. "27 eaa" -> "27", "563 eKr" -> "563"
            const m = s.match(/^-?\d+(\.\d+)?/);
            if (!m) return NaN;

            let n = parseFloat(m[0]);
            if (hasBce && n > 0) n = -n;

            return Number.isFinite(n) ? n : NaN;
        }

        // Absolute time pretty-print:
        // - prefer ISO date YYYY-MM-DD if available
        // - otherwise use a clean year string when sensible
        function buildDisplayAbs(src) {
            const y = parseYearFlexible(src?.year);
            if (Number.isFinite(y)) {
                // Keep a simple, neutral absolute form (no BCE suffix change now).
                // If you later want Finnish "eaa" here, we can switch to that.
                return String(Math.round(y));
            }
            if (typeof src?.date === 'string' && src.date.length >= 10) {
                return src.date.slice(0, 10); // "YYYY-MM-DD"
            }
            return '';
        }

        async function prepare() {
            try {
                // 1) Lataa uusi formaatti (meta + flat events)
                const res = await fetch('eventsDB45.json', { cache: 'no-store' });
                if (!res.ok) throw new Error('eventsDB45.json not found');
                const json = await res.json();

                // 2) Lue meta + värit
                const meta = json.meta || {};
                const themeDefs = meta.themes || {};

                // Rakenna themeColors metasta; fallbackit jos väri puuttuu
                const FALLBACK = ["#6372b2", "#70a8c6", "#4b9fa8", "#368d60", "#5a9646"];
                const themeColors = {};
                let i = 0;
                for (const t of Object.keys(themeDefs)) {
                    const c = (themeDefs[t] && themeDefs[t].color) || FALLBACK[Math.min(i, FALLBACK.length - 1)];
                    themeColors[t] = c; i++;
                }

                // 3) Teemajärjestys: ytimet ensin, sitten mahdolliset muut datassa
                const themesInData = Array.from(new Set((json.events || []).map(e => e.theme).filter(Boolean)));
                const themeOrder = THEME_ORDER_5.filter(t => themesInData.includes(t))
                    .concat(themesInData.filter(t => !THEME_ORDER_5.includes(t)));

                // 4) Laske time_years (ikä vuosina) uuteen skaalaan (ei DataUtil.normalizeDataa)
                const now = new Date();
                const nowMs = now.getTime();
                const nowDec = decimalYearFromDate(now);

                const baseEvents = (json.events || []).map(src => {
                    // Prefer 'year' (even if positive) over 'date' for age calculation.
                    // Accept year both as number and as string (BCE/eaa allowed).
                    const yearNum = parseYearFlexible(src.year);

                    let ageYears = NaN;
                    if (Number.isFinite(yearNum)) {
                        // From decimal year: nowDec - year
                        ageYears = nowDec - yearNum;
                    } else if (typeof src.date === "string") {
                        const t = Date.parse(src.date);
                        if (Number.isFinite(t)) {
                            ageYears = (nowMs - t) / (365.2425 * 24 * 3600 * 1000);
                        }
                    }

                    // Drop future events only (ageYears <= 0)
                    if (!Number.isFinite(ageYears) || ageYears <= 0) return null;

                    // jätä tulevaisuus pois (≤ 0)
                    if (!Number.isFinite(ageYears) || ageYears <= 0) return null;
                    // Compute preformatted Finnish display fields for the renderer
                    const ago = formatAgoFi(ageYears);
                    const display_abs = buildDisplayAbs(src);
                    const display_when = display_abs ? `${display_abs} · ${ago.text}` : ago.text;

                    return {
                        theme: src.theme,
                        id: src.id,
                        label: src.label,
                        display_label: src.label, // keep for UI
                        year: (typeof src.year === "number") ? src.year : undefined,
                        date: (typeof src.date === "string") ? src.date : undefined,

                        // relative age basis for layout
                        time_years: ageYears,

                        // NEW: pre-formatted display fields (Finnish)
                        ago_value: ago.value,
                        ago_unit: ago.unit,
                        display_ago: ago.text,
                        display_abs,
                        display_when,

                        author: src.author || "ChatGPT",
                        edit_date: src.edit_date || "2025-10-20",
                        info: src.info,
                        ref: src.ref,
                        language: src.language || meta.language || "fi"
                    };
                }
            ).filter(Boolean)
                    .sort((a, b) => b.time_years - a.time_years);

                // 5) Present-overlayn ankkurit (käytetään jo olemassa olevaa buildPresent()ia)
                const present = buildPresent().sort((a, b) => a.time_years - b.time_years);

                // 6) Yhdistä ja lisää present-teeman väri
                const merged = baseEvents.concat(present);
                const outThemes = Array.from(new Set([...themeOrder, 'present']));
                const outThemeColors = Object.assign({ present: '#ff8c42' }, themeColors);

                // 7) Julkaise timeline.js:lle
                window.TS_DATA = { meta, events: merged, themes: outThemes, themeColors: outThemeColors };
                console.info('[v45.4] TS_DATA prepared:', window.TS_DATA);

            } catch (e) {
                console.warn('[v45.4] prepare() failed, fallback to present-only:', e);
                const present = buildPresent().sort((a, b) => a.time_years - b.time_years);
                window.TS_DATA = { events: present, themes: ['present'], themeColors: { present: '#ff8c42' } };
            }
        }

        // Promise allows timeline.js to wait if needed
        window.TS_DATA_P = prepare();
    })();
</script>

    <script
        src="timeline.js"> // ------------------------------ main rendering module  //
    </script>

<script>
    /* v45.9 — Present theme live updater (simplified & stable)
       - Refreshes the “present” layer once per second.
       - Starts automatically when the intro animation completes.
       - Also refreshes immediately after any zoom/scroll render.
    */
    (function () {
        function refreshPresent(nowDate) {
            const present = (typeof buildPresent === 'function')
                ? buildPresent(nowDate).sort((a, b) => a.time_years - b.time_years)
                : [];
            const base = (window.TS_DATA?.events || []).filter(e => e.theme !== 'present');
            window.TS_DATA = Object.assign({}, window.TS_DATA, { events: base.concat(present) });
            if (typeof window.updateTimeline === 'function') window.updateTimeline();
        }

        let lastS = -1;
        function loop() {
            const t = Date.now(), s = Math.floor(t / 1000);
            if (s !== lastS) { lastS = s; refreshPresent(new Date(t)); }
            requestAnimationFrame(loop);
        }

        function startPresentLoop() {
            if (window.__presentLoopStarted) return;
            window.__presentLoopStarted = true;
            refreshPresent(new Date());
            requestAnimationFrame(loop);
        }

        // Start automatically when the intro animation finishes
        document.addEventListener('timeline:intro-done', startPresentLoop, { once: true });
        // Always refresh immediately on any render (zoom or scroll)
        document.addEventListener('timeline:render', () => refreshPresent(new Date()));
    })();
</script>


<script>
    /* Startup animation — simplified v55.9
       Always runs once after first render.
       Can be skipped explicitly with ?demo=0.
    */
    (function () {
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        // --- Touch cursor visuals (small white circle + ripple) ---
        function ensureTouchCursor() {
            let el = document.getElementById('touch-cursor');
            if (!el) {
                el = document.createElement('div');
                el.id = 'touch-cursor';
                el.style.cssText = [
                    'position:fixed;width:18px;height:18px;border-radius:50%;',
                    'background:rgba(255,255,255,0.95);',
                    'box-shadow:0 0 0 10px rgba(255,255,255,0.10),0 1px 6px rgba(0,0,0,.35);',
                    'z-index:1700;pointer-events:none;opacity:0;',
                    'transform:translate(-9px,-9px);',
                    'transition:opacity .20s ease,left .60s cubic-bezier(.2,.8,.2,1),top .60s cubic-bezier(.2,.8,.2,1);'
                ].join('');
                document.body.appendChild(el);
            }
            return el;
        }

        function moveTouchCursor(el, x, y, visible = true) {
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            el.style.opacity = visible ? '1' : '0';
        }

        function moveTouchCursorInstant(el, x, y, visible = true) {
            const prev = el.style.transition;
            el.style.transition = 'opacity .20s ease, left 0s, top 0s';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            el.style.opacity = visible ? '1' : '0';
            void el.offsetWidth;
            el.style.transition = prev;
        }

        function tapRipple(x, y) {
            const r = document.createElement('div');
            r.style.cssText = [
                'position:fixed;width:28px;height:28px;border-radius:50%;',
                'border:2px solid rgba(255,255,255,0.85);box-shadow:0 0 8px rgba(255,255,255,0.45);',
                'pointer-events:none;z-index:1699;opacity:0.85;',
                'transform:translate(-14px,-14px) scale(0.6);transition:transform .35s ease, opacity .35s ease;'
            ].join('');
            r.style.left = x + 'px';
            r.style.top = y + 'px';
            document.body.appendChild(r);
            requestAnimationFrame(() => {
                r.style.transform = 'translate(-14px,-14px) scale(1.15)';
                r.style.opacity = '0';
            });
            setTimeout(() => { if (r.parentNode) r.parentNode.removeChild(r); }, 400);
        }

        function hideTouchCursor(el) {
            if (!el) return;
            el.style.opacity = '0';
            setTimeout(() => { if (el.parentNode) el.parentNode.removeChild(el); }, 280);
        }

        // Find the screen position of a theme label
        function findThemeCenter(theme) {
            try {
                const svg = document.getElementById('timeline');
                if (!svg) return null;
                const titles = svg.querySelectorAll('text.card-title');
                for (const t of titles) {
                    if ((t.textContent || '').trim().toLowerCase() === String(theme).toLowerCase()) {
                        const r = t.getBoundingClientRect();
                        return { x: Math.round(r.left + r.width * 0.5), y: Math.round(r.top + r.height * 0.5) };
                    }
                }
            } catch (_) { }
            return null;
        }

        // --- Main startup sequence ---
        async function runStartup() {
            const api = window.TimelineAPI;
            if (!api) return;

            let cursor = ensureTouchCursor();

            // 1) Tap-select the theme whose title is closest to the vertical center (prefocus line)
            const svg = document.getElementById('timeline');
            const titles = svg?.querySelectorAll('text.card-title') || [];
            const midY = window.innerHeight / 2;

            let nearest = null, bestDist = Infinity;
            titles.forEach(t => {
                const r = t.getBoundingClientRect();
                const cy = r.top + r.height * 0.5;
                const d = Math.abs(cy - midY);
                if (d < bestDist) {
                    bestDist = d;
                    nearest = { el: t, x: r.left + r.width * 0.5, y: cy, theme: t.textContent.trim() };
                }
            });

            const target = nearest || { x: window.innerWidth / 2, y: midY, theme: null };

            // Visual tap cue
            moveTouchCursor(cursor, target.x, target.y, true);
            await sleep(520);
            tapRipple(target.x, target.y);

            // Select the theme if available
            if (target.theme && api.selectTheme) {
                api.selectTheme(target.theme);
            }

            // Pause shortly (touch released)
            moveTouchCursor(cursor, target.x, target.y, false);
            await sleep(1000);

            // 2) Zoom gesture using target as reference
            const cont = document.getElementById('timeline-container');
            const r = cont.getBoundingClientRect();
            const start = { x: Math.round(r.left + r.width * 0.5), y: target.y };
            tapRipple(start.x, start.y);
            await sleep(260);

            cursor = ensureTouchCursor();
            moveTouchCursorInstant(cursor, start.x, start.y, true);
            await sleep(180);

            // Zoom in and out around the target position
            const dx = 120;
            api.animScaleBy(1.5, start.x, start.y, 700);
            moveTouchCursor(cursor, start.x - dx, start.y, true);
            await sleep(740);

            api.animScaleBy(0.8, start.x - dx, start.y, 560);
            moveTouchCursor(cursor, start.x, start.y, true);
            await sleep(600);

            // 3) Scroll up and down
            await sleep(500);
            const dy = -90;
            moveTouchCursor(cursor, start.x, start.y + dy, true);
            api.animTranslateBy(0, dy, 620);
            await sleep(660);

            moveTouchCursor(cursor, start.x, start.y, true);
            api.animTranslateBy(0, -dy, 520);
            await sleep(540);

            hideTouchCursor(cursor);

            // Signal intro completion
            window.__introCompleted = true;
            document.dispatchEvent(new CustomEvent('timeline:intro-done'));
        }

        // --- Start logic (simplified) ---
        document.addEventListener('timeline:first-render', () => {
            const url = new URL(location.href);
            const demoParam = url.searchParams.get('demo');
            const force = demoParam !== '0'; // default: run, unless ?demo=0
            if (!force) {
                console.log('[startup] skipped by ?demo=0');
                window.__introCompleted = true;
                document.dispatchEvent(new CustomEvent('timeline:intro-done'));
                return;
            }
            console.log('[startup] running intro');
            setTimeout(runStartup, 380);
        });
    })();
</script>

</body>

</html>