<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
        <title>History Timeline v44</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link rel="stylesheet" href="style.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <h1 id="page-title">
        History at your fingertips — Big Bang to 2025
        <span style="font-size:0.65em; color:#9e9d9d;">v44</span>
    </h1>

    <div id="info-toggle">?</div>
<div id="info-box" style="display:none;">
    <div id="help-message">
        <p><em>Experimental visualization</em> of history across an immense time span.</p>
        <p>A vertical, <em>zoomable logarithmic timeline</em> of key events from the Big Bang to the present
            (2025).</p>
        <p>Events are grouped into <em>partly overlapping themes</em> that you can bring to the front.</p>

        <hr style="border:none; border-top:1px solid #ddd; margin:8px 0;">
        <!-- pikavinkit -->
        <p><em>Tips:</em> Pinch/scroll content or swipe L/R to zoom · Click a theme card to focus · Tap an event
            for notes</p>
    </div>

    <!-- status päivittyy skriptistä -->
    <div id="status-message" style="font-size:0.75em; color:#666; margin-top:2px;">
        Loading…
    </div>

    <!-- erillinen author-kenttä, EI muutu skriptissä -->
    <div id="author" style="font-size:0.75em; color:#666; margin-top:6px;">
        Authors: Jukka Linjama &amp; ChatGPT 5.0. 
    </div>

    <div id="license-info" style="font-size:0.7em; color:#666; margin-top:6px;">
        Project in <a href="https://github.com/JukkaTLinjama/log-aikajana" target="_blank">Github</a>
        Shared as an <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>
        experiment.<br>
        Enjoy &amp; share!
    </div>
</div>

    <div id="timeline-container">
        <svg id="timeline"></svg>
    </div>

    <div id="page-footer">© 2025 JL · CC BY 4.0</div>

    <script>
        // Debug switch via ?debug=1
        (function () {
            const u = new URL(location.href);
            const dbg = u.searchParams.get("debug") === "1";
            // näkyvä pieni virhepalkki vain debug-tilassa
            if (dbg) {
                const bar = document.createElement("div");
                bar.id = "debug-bar";
                bar.style.cssText = "position:fixed;left:0;right:0;bottom:0;z-index:99999;font:12px/1.4 system-ui;padding:6px 10px;background:#300;color:#fdd;display:none";
                bar.textContent = "Debug on. Errors will appear here.";
                document.addEventListener("DOMContentLoaded", () => document.body.appendChild(bar));
                window.__DBG__ = true;
                window.addEventListener("error", (e) => {
                    bar.style.display = "block";
                    bar.textContent = "Error: " + (e.message || "unknown");
                    console.error("[timeline:error]", e.message, e.error);
                });
                window.addEventListener("unhandledrejection", (e) => {
                    bar.style.display = "block";
                    bar.textContent = "Promise error: " + (e.reason && (e.reason.message || e.reason));
                    console.error("[timeline:promise]", e.reason);
                });
                console.log("%c[debug] enabled", "color:#9f9");
            }
        })();
    </script>

    <!-- Lightweight helpers (no side effects). Loaded before timeline.js -->
    <script>
        (function () {
            if (window.Util) return; // avoid double-load
            const Util = {};

            /** Try/catch wrapper for draw/layout functions. */
            Util.safe = function safe(fn, label) {
                try { return (typeof fn === "function") ? fn() : undefined; }
                catch (err) {
                    const msg = `[${label}] ${err && err.message ? err.message : err}`;
                    console.error("[timeline:render]", label, err);
                    const bar = document.getElementById("debug-bar");
                    if (bar) { bar.style.display = "block"; bar.textContent = "Render error: " + msg; }
                }
            };

            /** Debounce helper. */
            Util.debounce = function debounce(fn, ms) {
                let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
            };

            /** Perf timer: logs only when debug (?debug=1) is on. */
            Util.timed = function timed(label, fn) {
                const t0 = performance.now();
                const out = fn();
                const t1 = performance.now();
                if (window.__DBG__) console.log(`[perf] ${label}: ${(t1 - t0).toFixed(1)} ms`);
                return out;
            };

            /** Clamp helper. */
            Util.clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

            Util.textHaloOffset = function (yEvt, yFoc) {
                const R = 40, MAX = 8;
                const dy = yEvt - yFoc, ady = Math.abs(dy);
                if (ady === 0 || ady >= R) return 0;
                const t = 1 - ady / R;
                return Math.sign(dy) * MAX * Math.pow(t, 1.0);
            };
            // ---------------- Card text helpers (pure, DOM-free) ----------------

            /** Preferred display label for an event (falls back to 'label'). */
            Util.eventLabel = function (ev) {
                return (ev?.display_label || ev?.label || '').toString();
            };

            /** One-line meta string (e.g., year + theme if present). */
            Util.eventMeta = function (ev) {
                const year = (ev?.year ?? '').toString();
                const theme = ev?.theme ? `Theme: ${ev.theme}` : null;
                return [year, theme].filter(Boolean).join(' · ');
            };

            /** Safe truncation with ellipsis; avoids breaking short strings. */
            Util.truncate = function (str, max = 60, suffix = '…') {
                const s = (str ?? '').toString();
                if (max <= 0) return '';
                if (s.length <= max) return s;
                // preserve word boundary if possible
                const cut = s.slice(0, max - suffix.length);
                const ws = cut.lastIndexOf(' ');
                return (ws >= 24 ? cut.slice(0, ws) : cut) + suffix;
            };
            // --- Card metrics (pure, DOM-free except bbox reads) ---
            // Computes paddings and rect based on measured text heights.
            Util.cardMetrics = function (titleSel, groupSel, yTopEv, yBotEv, viewH) {
                const titleH = Math.ceil((() => { try { return titleSel.node().getBBox().height; } catch { return 10; } })()) || 10;
                const tmp = groupSel.append("text").attr("class", "event-label").attr("visibility", "hidden").text("X");
                const evH = Math.ceil((() => { try { return tmp.node().getBBox().height; } catch { return 9; } })()) || 9;
                tmp.remove();

                const topPad = titleH + 6;
                const botPad = Math.ceil(evH * 2.2) + 8;
                const yRect = Math.min(yTopEv, yBotEv) - topPad;
                const hRect = Math.abs(yBotEv - yTopEv) + topPad + botPad;

                const fullyAbove = (yRect + hRect) < 15;
                const fullyBelow = yRect > viewH;

                return { topPad, botPad, yRect, hRect, fullyAbove, fullyBelow };
            };

            window.Util = Util;
        })();
    </script>
    <script>
        // -----------------------------------------------------------
        // TS_CFG / TS_DELAY
        // Global configuration objects used by timeline.js
        // Keep them here so values are easy to tweak without touching JS files.
        // -----------------------------------------------------------
        window.TS_CFG = {
            // Margins for the timeline viewport (pixels)
            margin: { top: 12, right: 54, bottom: 12, left: 54 },

            // Right-side zoom bar dimensions
            zoomBar: { width: 22, gap: 10 },

            // Event card layout parameters
            card: { minW: 160, pad: 10 },

            // Color palette used for event themes
            palette: ["#6372b2ff", "#70a8c6", "#4b9fa8", "#368d60ff", "#5a9646ff"],

            // Prefocus halo behavior (for focus highlight transitions)
            prefocus: { radiusPx: 16, hysteresisPx: 8 }
        };

        // Global timing delays for UI interactions (ms)
        window.TS_DELAY = { ACTIVATE: 1000, ZOOM: 1500 };
    </script>

    <script>
        // -----------------------------------------------------------
        // InfoBox module
        // Handles the small popup panel showing detailed info about an event.
        // Encapsulated in an IIFE so it doesn't leak global variables.
        // Accessible through window.InfoBox.show(event, screenBox)
        // and window.InfoBox.hide().
        // -----------------------------------------------------------
        (function () {
            const infoCfg = { margin: 10 };  // minimal distance from window edges (px)
            let infoEl = null;               // singleton DOM element for the popup

            // Ensure the info box element exists (lazy creation)
            function ensureInfoEl() {
                if (infoEl && infoEl.parentNode) return infoEl;
                infoEl = document.createElement('div');
                infoEl.id = 'event-info';
                document.body.appendChild(infoEl);
                // Prevent clicks inside the box from bubbling (so it doesn’t close)
                infoEl.addEventListener('click', e => e.stopPropagation());
                return infoEl;
            }

            // Build inner HTML structure for the info popup based on event data
            function buildEventHTML(ev) {
                const label = ev?.display_label || ev?.label || 'Event';
                const year = (ev?.year ?? '').toString();
                const meta = [year, ev?.theme ? `Theme: ${ev.theme}` : null]
                    .filter(Boolean)
                    .join(' · ');
                const comments = (ev?.comments || '').trim();
                const ref = (ev?.ref || '').trim();

                // Main text or placeholder if no comments
                const body = comments
                    ? `<div class="body">${comments}</div>`
                    : `<div class="body" style="opacity:.8;">(No notes)</div>`;

                // Optional reference link
                const link = ref && /^https?:\/\//i.test(ref)
                    ? `<div class="hint">Ref: <a href="${ref}" target="_blank" rel="noopener">link</a></div>`
                    : (ref ? `<div class="hint">Ref: ${ref}</div>` : ``);

                // Final assembled HTML
                return `
            <div class="title">${label}</div>
            <div class="meta">${meta}</div>
            ${body}${link}
            <div class="hint">Tip: click outside to close.</div>
        `;
            }

            // Show the info box at a screen position derived from the event’s bounding box
            function show(ev, screenBox) {
                const el = ensureInfoEl();
                el.innerHTML = buildEventHTML(ev);
                el.classList.remove('is-visible');
                // Initial hidden state for animation (fade + small scale)
                el.style.visibility = 'hidden';
                el.style.opacity = '0';
                el.style.transform = 'translateY(6px) scale(0.98)';

                requestAnimationFrame(() => {
                    const rect = el.getBoundingClientRect();
                    const M = infoCfg.margin;
                    let x = Math.round(screenBox.left + 12);
                    let y = Math.round(screenBox.top - rect.height - 8);

                    // If it would go offscreen above, move below the event instead
                    if (y < M) y = Math.round(screenBox.bottom + 8);
                    // Clamp to right and bottom edges
                    if (x + rect.width + M > innerWidth)
                        x = Math.max(M, innerWidth - rect.width - M);
                    if (y + rect.height + M > innerHeight)
                        y = Math.max(M, innerHeight - rect.height - M);

                    el.style.left = `${x}px`;
                    el.style.top = `${y}px`;

                    // Trigger CSS transition to visible state
                    requestAnimationFrame(() => {
                        el.style.visibility = '';
                        el.style.opacity = '';
                        el.style.transform = '';
                        el.classList.add('is-visible');
                    });
                });
            }

            // Hide the info box (simply remove visible class)
            function hide() {
                const el = ensureInfoEl();
                el.classList.remove('is-visible');
            }

            // Close on click outside or Escape key
            document.addEventListener('click', hide);
            document.addEventListener('keydown', e => { if (e.key === 'Escape') hide(); });

            // Expose public API
            window.InfoBox = { show, hide };
        })();
    </script>

    <script>
        // -----------------------------------------------
        // SwipeZoom module: handles touch and mouse gestures for zooming and panning
        // Horizontal swipe in center area → zoom in/out
        // Vertical swipe outside center area → pan up/down
        // This replaces the old setupGlobalSwipeZoom() in timeline.js
        // -----------------------------------------------
        (function () {
            /**
             * Attach gesture handling to an SVG element.
             * @param {d3.Selection} svgSel - the d3 selection for main SVG
             * @param {d3.ZoomBehavior} zoomBehavior - the D3 zoom behavior already created
             * @param {object} opts - optional parameters
             *   innerHeight: function returning window height (used to detect center zone)
             */
            function attach(svgSel, zoomBehavior, opts) {
                const innerHeight = (opts && opts.innerHeight) || (() => window.innerHeight);

                // --- gesture tuning constants ---
                const DEAD = 3;              // minimal movement before mode is decided
                const DOM_RATIO = 1.5;       // horizontal dominance threshold
                const SENS_TOUCH = -0.006;   // zoom sensitivity for touch
                const SENS_MOUSE = -0.003;   // zoom sensitivity for mouse
                const STEP = 20;             // max delta per frame
                const CLAMP_MIN = 0.95;      // minimal scale per step
                const CLAMP_MAX = 1.05;      // maximal scale per step

                // --- internal state ---
                let active = false;          // pointer currently down
                let mode = null;             // 'zoom' | 'pan' | null
                let startX = 0, startY = 0, lastX = 0, lastY = 0;
                let startInCenter = false;     // did gesture start in center zone?

                // --- helper: check if pointer Y is within the central zoom zone ---
                function inCenterZone(y) {
                    const H = innerHeight();
                    const zoneH = Math.max(80, Math.min(H * 0.36, 160)); // 80–160px or ~1/3 screen
                    const y0 = (H - zoneH) / 2, y1 = y0 + zoneH;
                    return y >= y0 && y <= y1;
                }

                const isTouch = (e) => e.pointerType === 'touch';
                const svgNode = svgSel.node();
                const contEl = document.getElementById('timeline-container');

                // --- visual feedback class toggle ---
                function setGestureActive(on) {
                    if (on) {
                        svgNode.classList.add('gesture-active');
                        if (contEl) contEl.classList.add('gesture-active');
                    } else {
                        svgNode.classList.remove('gesture-active');
                        if (contEl) contEl.classList.remove('gesture-active');
                    }
                }

                // -----------------------------------------------
                // pointerdown → start tracking
                // -----------------------------------------------
                svgNode.addEventListener('pointerdown', (e) => {
                    if (!e.isPrimary) return;        // ignore secondary touches
                    active = true; mode = null;
                    startX = lastX = e.clientX;
                    startY = lastY = e.clientY;
                    startInCenter = inCenterZone(e.clientY);
                    try { e.target.setPointerCapture(e.pointerId); } catch { }
                    e.stopPropagation();
                }, { passive: true, capture: true });

                // -----------------------------------------------
                // pointermove → decide mode and perform zoom/pan
                // -----------------------------------------------
                svgNode.addEventListener('pointermove', (e) => {
                    if (!active || !e.isPrimary) return;
                    const dxTot = e.clientX - startX;
                    const dyTot = e.clientY - startY;

                    // --- determine mode when movement passes threshold ---
                    if (mode === null && (Math.abs(dxTot) >= DEAD || Math.abs(dyTot) >= DEAD)) {
                        const horizDominates = (Math.abs(dxTot) > Math.abs(dyTot) * DOM_RATIO);
                        mode = (horizDominates && startInCenter) ? 'zoom' : 'pan';
                        setGestureActive(true);
                    }

                    // --- zoom mode ---
                    if (mode === 'zoom') {
                        const dxStep = Math.max(-STEP, Math.min(STEP, e.clientX - lastX));
                        if (Math.abs(dxStep) >= DEAD) {
                            lastX = e.clientX;
                            const sens = isTouch(e) ? SENS_TOUCH : SENS_MOUSE;
                            const factor = Math.max(CLAMP_MIN, Math.min(CLAMP_MAX, 1 + dxStep * sens));
                            // D3 handles scaling relative to pointer position
                            svgSel.call(zoomBehavior.scaleBy, factor, [e.clientX, e.clientY]);
                        }
                        e.stopPropagation();
                        return;
                    }

                    // --- pan mode ---
                    if (mode === 'pan') {
                        const dyStep = Math.max(-STEP, Math.min(STEP, e.clientY - lastY));
                        if (Math.abs(dyStep) >= DEAD) {
                            lastY = e.clientY;
                            svgSel.call(zoomBehavior.translateBy, 0, dyStep);
                        }
                        e.stopPropagation();
                        return;
                    }

                    e.stopPropagation();
                }, { passive: true, capture: true });

                // -----------------------------------------------
                // pointerup / cancel / lostcapture → reset
                // -----------------------------------------------
                const end = () => {
                    active = false; mode = null;
                    setGestureActive(false);
                };
                svgNode.addEventListener('pointerup', end, { passive: true, capture: true });
                svgNode.addEventListener('pointercancel', end, { passive: true, capture: true });
                svgNode.addEventListener('lostpointercapture', end, { passive: true, capture: true });
            }

            // Expose globally for timeline.js
            window.SwipeZoom = { attach };
        })();
    </script>
    <script>
        // -------------------------------------------------------
        // Ticks: compute major/minor tick values for a log domain
        // - majors: 10^n within [d0, d1]
        // - minors: 2..9 × 10^n within [d0, d1] (optional)
        // Keep this pure (no DOM), so it's easy to move to utils.js later.
        // -------------------------------------------------------
        (function () {
            function majorsFromDomain(d0, d1) {
                // Ensure ascending domain
                if (d0 > d1) [d0, d1] = [d1, d0];
                const n0 = Math.floor(Math.log10(d0));
                const n1 = Math.floor(Math.log10(d1));
                const values = [];
                for (let e = n0; e <= n1; e++) {
                    const v = Math.pow(10, e);
                    if (v >= d0 && v <= d1) values.push(v);
                }
                // Exponents parallel to major values (for label building)
                const exponents = [];
                for (let e = n0; e <= n1; e++) exponents.push(e);
                return { exponents, values };
            }

            function minorsFromDomain(d0, d1, showMinor) {
                if (!showMinor) return [];
                if (d0 > d1) [d0, d1] = [d1, d0];
                const out = [];
                const n0 = Math.floor(Math.log10(d0));
                const n1 = Math.floor(Math.log10(d1));
                for (let e = n0; e <= n1; e++) {
                    const base = Math.pow(10, e);
                    for (let m = 2; m <= 9; m++) {
                        const v = m * base;
                        if (v >= d0 && v <= d1) out.push(v);
                    }
                }
                return out;
            }

            window.Ticks = { majorsFromDomain, minorsFromDomain };
        })();
    </script>
    <script>
        // -------------------------------------------------------
        // CenterBand: pure math for the center zone geometry
        // Computes the vertical center line (midY), the zoom zone band (zoneY/zoneH),
        // and the horizontal endpoints (xLeft/xRight) for the center hairline.
        // Inputs are plain numbers; no DOM access here to keep it reusable.
        // -------------------------------------------------------
        (function () {
            /**
             * Compute geometry for the center band and hairline.
             * @param {number} w - svg width (outer)
             * @param {number} h - svg height (outer)
             * @param {number|NaN} axisRight - right edge (px) of the axis group, or NaN if unknown
             * @param {number|NaN} zoomBarLeft - left edge (px) of the zoom bar/track, or NaN if unknown
             * @returns {{zoneY:number, zoneH:number, midY:number, xLeft:number, xRight:number}}
             */
            function compute(w, h, axisRight, zoomBarLeft) {
                // Vertical band in the middle of the screen (used as "zoom allowed" zone)
                const zoneH = Math.max(80, Math.min(h * 0.36, 160)); // clamp 80–160 px
                const zoneY = (h - zoneH) / 2;
                const midY = Math.round(h / 2);

                // Horizontal endpoints: keep the hairline clear of axis and zoom bar
                const DEFAULT_LEFT_INSET = 14; // fallback padding from the left edge
                const DEFAULT_RIGHT_INSET = 4;  // fallback padding from the right edge
                const AXIS_GAP = 1;            // extra space after axis
                const ZOOMB_GAP = 15;           // extra space before zoom bar

                // Build endpoints with sensible fallbacks
                let xLeft = Number.isFinite(axisRight) ? Math.ceil(axisRight + AXIS_GAP) : DEFAULT_LEFT_INSET;
                let xRight = Number.isFinite(zoomBarLeft) ? Math.floor(zoomBarLeft - ZOOMB_GAP) : (w - DEFAULT_RIGHT_INSET);

                // Clamp to viewport
                xLeft = Math.max(0, Math.min(xLeft, w - DEFAULT_RIGHT_INSET));
                xRight = Math.max(DEFAULT_LEFT_INSET, Math.min(xRight, w));

                // If span is too short, relax a bit but stay reasonable
                const span = xRight - xLeft;
                if (span < w * 0.3) {
                    const leftRelax = Number.isFinite(axisRight) ? Math.min(axisRight + AXIS_GAP, 40) : 0;
                    const rightRelax = Number.isFinite(zoomBarLeft) ? Math.min((w - zoomBarLeft) + ZOOMB_GAP, 40) : 0;
                    xLeft = DEFAULT_LEFT_INSET + leftRelax;
                    xRight = w - DEFAULT_RIGHT_INSET - rightRelax;
                }

                // Final safety: ensure at least a minimal centered segment
                if ((xRight - xLeft) < 24) {
                    const cx = Math.round(w / 2);
                    xLeft = cx - 12;
                    xRight = cx + 12;
                }

                return { zoneY, zoneH, midY, xLeft, xRight };
            }

            // Expose as a tiny module
            window.CenterBand = { compute };
        })();
    </script>
<script>
    // -------------------------------------------------------
    // DataUtil: normalizeData()
    // Preprocesses loaded eventsDB.json:
    //  - merges group.theme into each event
    //  - applies i18n labels for given language
    //  - extracts theme order and colors
    // -------------------------------------------------------
    (function () {
        function normalizeData(data, lang) {
            const meta = data.meta || {};
            const ui = meta.ui || {};
            const themeOrder = Array.isArray(ui.themeOrder) ? ui.themeOrder : null;
            const themeColors = ui.themeColors || null;

            const events = (data.events || []).flatMap(g =>
                (g.events || []).map(e => ({
                    ...e,
                    theme: g.theme,
                    display_label:
                        (e.i18n && e.i18n[lang] && e.i18n[lang].label)
                            ? e.i18n[lang].label
                            : e.label
                }))
            );

            const themes = themeOrder
                ? themeOrder.filter(t => events.some(e => e.theme === t))
                : Array.from(new Set(events.map(e => e.theme)));

            return { events, themes, themeColors };
        }

        // Expose globally for timeline.js
        window.DataUtil = { normalizeData };
    })();
</script>

    <script src="timeline.js"></script>
    
    <script>     // Startup animation: ---------------------------------------------------------------------------
        const nav = performance.getEntriesByType('navigation')[0];
            if (nav && nav.type === 'reload') {
                sessionStorage.removeItem('startup_v41_shown');
            }

        (function(){
            function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // --- Touch cursor helpers (Chrome DevTools -tyylinen pallo) ---
    function ensureTouchCursor(){
                let el = document.getElementById('touch-cursor');
            if(!el){
                el = document.createElement('div');
                el.id = 'touch-cursor';
                // inline style backup (jos style.css puuttuu)
                el.style.cssText = [
                'position:fixed;width:18px;height:18px;border-radius:50%;',
                'background:rgba(255,255,255,0.95);',
                'box-shadow:0 0 0 10px rgba(255,255,255,0.10),0 1px 6px rgba(0,0,0,.35);',
                'z-index:1700;pointer-events:none;opacity:0;',
                'transform:translate(-9px,-9px);',
                'transition:opacity .20s ease,left .60s cubic-bezier(.2,.8,.2,1),top .60s cubic-bezier(.2,.8,.2,1);'
                ].join('');
                document.body.appendChild(el);
            }
        return el;
        }

        function moveTouchCursor(el, x, y, visible=true){
            el.style.left = x + 'px';
        el.style.top  = y + 'px';
        el.style.opacity = visible ? '1' : '0';
        }

        function moveTouchCursorInstant(el, x, y, visible = true) {
                const prev = el.style.transition;
                el.style.transition = 'opacity .20s ease, left 0s, top 0s';
                el.style.left = x + 'px';
                el.style.top = y + 'px';
                el.style.opacity = visible ? '1' : '0';
                void el.offsetWidth; // force layout so it "jumps"
                el.style.transition = prev || 'opacity .20s ease,left .60s cubic-bezier(.2,.8,.2,1),top .60s cubic-bezier(.2,.8,.2,1)';
        }

        function tapRipple(x,y){
            // kevyt "pulse" ilman riippuvuutta ulkoisesta CSS:stä
            const r = document.createElement('div');
                r.style.cssText = [
                'position:fixed;width:28px;height:28px;border-radius:50%;',
                'border:2px solid rgba(255,255,255,0.85);box-shadow:0 0 8px rgba(255,255,255,0.45);',
                'pointer-events:none;z-index:1699;opacity:0.85;',
                'transform:translate(-14px,-14px) scale(0.6);transition:transform .35s ease, opacity .35s ease;'
                ].join('');
                r.style.left = x + 'px';
                r.style.top  = y + 'px';
                document.body.appendChild(r);
            requestAnimationFrame(()=>{
                    r.style.transform = 'translate(-14px,-14px) scale(1.15)';
                r.style.opacity = '0';
            });
            setTimeout(()=>{ if(r.parentNode) r.parentNode.removeChild(r); }, 400);
        }

        function hideTouchCursor(el){
            if(!el) return;
                el.style.opacity = '0';
            setTimeout(()=>{ if(el.parentNode) el.parentNode.removeChild(el); }, 280);
        }

        // Etsi "ihmiskunta" otsikon ruutu-koordinaatti; fallback = TimelineAPI.getCenter()
        function findThemeCenter(theme){
            try{
            const svg = document.getElementById('timeline');
                if(!svg) return null;
                const titles = svg.querySelectorAll('text.card-title');
                for(const t of titles){
                if((t.textContent || '').trim().toLowerCase() === String(theme).toLowerCase()){
                const r = t.getBoundingClientRect();
                return {x: Math.round(r.left + r.width*0.5), y: Math.round(r.top + r.height*0.5) };
                }
            }
            } catch(_){ }
                return null;
        }

        // --- Startup sequence ---
        // Järjestys: tap "ihmiskunta" → 1s tauko → aloita 50px oikealta → zoom in +50% → out −20% → scroll up + down
        async function runStartup(){
        const api = window.TimelineAPI;
        if (!api) return;

        let cursor = ensureTouchCursor();

        // 1) Tap-select "ihmiskunta"
        const cTap = findThemeCenter('ihmiskunta') || api.getCenter();
        moveTouchCursor(cursor, cTap.x, cTap.y, true);
        await sleep(520);
        tapRipple(cTap.x, cTap.y);
        api.selectTheme('ihmiskunta');

        // tauko 1 s (touch irti)
        moveTouchCursor(cursor, cTap.x, cTap.y, false);
        await sleep(1000);

        // uusi aloitus oikean reunan lähelle
        const cont = document.getElementById('timeline-container');
        const r = cont.getBoundingClientRect();
        const start = { x: Math.round(r.left + r.width * 0.5), y: cTap.y };
        // tap + ripple uudessa paikassa → käyttäjälle selkeä vihje "aloita täältä"
        tapRipple(start.x, start.y);
        await sleep(260);

        // tuo "sormi" näkyviin suoraan uuteen kohtaan (ei liukua)
        cursor = ensureTouchCursor();
        moveTouchCursorInstant(cursor, start.x, start.y, true);
        await sleep(180);

        // Zoom (reversed mapping): swipe LEFT = zoom IN, swipe RIGHT = zoom OUT
        const dx = 120;  // swipe distance
        const kIn = 1.5;  // +50%
        const kOut = 0.8;  // −20%

        // zoom in — drag LEFT from start to start - dx, anchor at start
        moveTouchCursor(cursor, start.x - dx, start.y, true);
        api.animScaleBy(kIn, start.x, start.y, 700);
        await sleep(740);

        // zoom out — drag RIGHT back to start, anchor at the left end
        moveTouchCursor(cursor, start.x, start.y, true);
        api.animScaleBy(kOut, start.x - dx, start.y, 560);
        await sleep(600);

        // 3) Scroll: ylös ja alas samasta start-kohdasta
        await sleep(500);
        const dy = -90;
        moveTouchCursor(cursor, start.x, start.y + dy, true);
        api.animTranslateBy(0, dy, 620);
        await sleep(660);

        moveTouchCursor(cursor, start.x, start.y, true);
        api.animTranslateBy(0, -dy, 520);
        await sleep(540);

        hideTouchCursor(cursor);
  }

  // Aja kerran / sessio (ohitus: ?demo=1)
  document.addEventListener('timeline:ready', () => {
    if (matchMedia('(prefers-reduced-motion: reduce)').matches) return;

        const url = new URL(location.href);
        const force = url.searchParams.get('demo') === '1';
        const SS_KEY = 'startup_v41_shown';

        if (!force) {
      if (sessionStorage.getItem(SS_KEY) === '1') return;
        sessionStorage.setItem(SS_KEY, '1');
    }
        setTimeout(runStartup, 380);
        const infoToggle = document.getElementById('info-toggle');
      const infoBox = document.getElementById('info-box');

      if (infoToggle && infoBox) {
          infoToggle.addEventListener('click', async (e) => {
              // Intercept only the first click on "?" so our sequence runs first.
              e.preventDefault();
              e.stopPropagation();

              // Play the same startup animation regardless of session flag
              await runStartup();

              // Open the info box after animation
              infoBox.hidden = false;
              infoBox.style.display = 'block';
          }, { capture: true, once: true });
      }

  });
})();
</script>

</body>

</html>