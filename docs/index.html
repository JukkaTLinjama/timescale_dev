<!DOCTYPE html>
<html lang="en">

<head>
    <!--
    Timeline v48 — file structure (short version)
    =============================================
    - index.html        : HTML layout, styles, minimal glue.
    - style.css         : Styles (cards, InfoBox, editor panel).
    - editor.js         : Editor module (draft store + inline editor + toolbar)
                          + InfoBox popup + Startup intro (one file to keep things simple).
    - timeline.js       : Core renderer (scales, zoom/pan, draw cards/axis, TimelineAPI).
    
    Load order:
      1) d3.js (library)
      2) editor.js   (provides InfoBox + intro + StagingStore before renderer)
      3) timeline.js (renderer uses InfoBox, exposes TimelineAPI)
    
    Notes:
      - Skip startup intro with ?demo=0
      - Editor drafts are kept in localStorage (key: TS_DRAFTS_v47)
      - “Edit event” in InfoBox dispatches window event: `timeline:edit-event`
    -->
    <meta charset="UTF-8">
        <title>History Timeline v48.1  </title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link rel="stylesheet" href="style.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>

</head>

<body>
    <h1 id="page-title">
        History at your fingertips — Big Bang to 2025
        <span style="font-size:0.65em; color:#9e9d9d;">v48.1 </span>
    </h1>

    <div id="info-toggle">?</div>
    <div id="info-box" style="display:none; position:fixed; z-index:2600;">
    <div id="help-message">
        <p><em>Experimental visualization</em> of history across an immense time span.</p>
        <p>A vertical, <em>zoomable logarithmic timeline</em> of key events from the Big Bang to the present
            (2025).</p>
        <p>Events are grouped into <em>partly overlapping themes</em> that you can bring to the front.</p>

        <hr style="border:none; border-top:1px solid #ddd; margin:8px 0;">
        <!-- pikavinkit -->
        <p><em>Tips:</em> Pinch/scroll content or swipe L/R to zoom · Click a theme card to focus · Tap an event
            for notes</p>
    </div>

    <!-- status päivittyy skriptistä -->
    <div id="status-message" style="font-size:0.75em; color:#666; margin-top:2px;">
        Loading…
    </div>

    <!-- erillinen author-kenttä, EI muutu skriptissä -->
    <div id="author" style="font-size:0.75em; color:#666; margin-top:6px;">
        Authors: Jukka Linjama &amp; ChatGPT 5.0. 
    </div>

    <div id="license-info" style="font-size:0.7em; color:#666; margin-top:6px;">
        Project in <a href="https://github.com/JukkaTLinjama/log-aikajana" target="_blank">Github</a>
        Shared as an <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>
        experiment.<br>
        Enjoy &amp; share!
    </div>
</div>

    <div id="timeline-container">
        <svg id="timeline"></svg>
    </div>

    <!-- v46.4: Inline Event Editor -->
    <div id="event-editor" hidden>
        <div class="editor-header">
            <div class="editor-title">Edit event</div>
            <button id="close-editor" title="Close editor">×</button>
        </div>
        <div class="editor-body">
            <label>Title</label>
            <input id="edit-title" type="text">

            <label>Year</label>
            <input id="edit-year" type="text">

            <label>Description</label>
            <textarea id="edit-desc" rows="4"></textarea>

            <label>Theme</label>
            <input id="edit-theme" type="text">
            <!-- v46.4+: meta & link fields -->
            <label>ID</label>
            <input id="edit-id" type="text" readonly>
            
            <label>Date</label>
            <input id="edit-date" type="text">
            
            <label>Link text</label>
            <input id="edit-link-text" type="text">
            
            <label>Link URL</label>
            <input id="edit-link-url" type="url" placeholder="https://…">
            
            <label>Source</label>
            <input id="edit-source" type="text" placeholder="e.g. Wikipedia, DOI, book…">
            
            <label>Tags (comma-separated)</label>
            <input id="edit-tags" type="text" placeholder="physics, cosmology">
            
            <label>Edited by</label>
            <input id="edit-edited-by" type="text">
            
            <label>Edited at</label>
            <input id="edit-edited-at" type="text" placeholder="ISO or free text">
            
            <label>Created by</label>
            <input id="edit-created-by" type="text">
            
            <label>Created at</label>
            <input id="edit-created-at" type="text" placeholder="ISO or free text">
        </div>
    </div>

    <div id="page-footer">© 2025 JL · CC BY 4.0</div>

    <script>
        // Debug switch via ?debug=1
        (function () {
            const u = new URL(location.href);
            const dbg = u.searchParams.get("debug") === "1";
            // näkyvä pieni virhepalkki vain debug-tilassa
            if (dbg) {
                const bar = document.createElement("div");
                bar.id = "debug-bar";
                bar.style.cssText = "position:fixed;left:0;right:0;bottom:0;z-index:99999;font:12px/1.4 system-ui;padding:6px 10px;background:#300;color:#fdd;display:none";
                bar.textContent = "Debug on. Errors will appear here.";
                document.addEventListener("DOMContentLoaded", () => document.body.appendChild(bar));
                window.__DBG__ = true;
                window.addEventListener("error", (e) => {
                    bar.style.display = "block";
                    bar.textContent = "Error: " + (e.message || "unknown");
                    console.error("[timeline:error]", e.message, e.error);
                });
                window.addEventListener("unhandledrejection", (e) => {
                    bar.style.display = "block";
                    bar.textContent = "Promise error: " + (e.reason && (e.reason.message || e.reason));
                    console.error("[timeline:promise]", e.reason);
                });
                console.log("%c[debug] enabled", "color:#9f9");
            }
        })();
    </script>

    <!-- Lightweight helpers (no side effects). Loaded before timeline.js -->
    <script>
        (function () {
            if (window.Util) return; // avoid double-load
            const Util = {};

            /** Try/catch wrapper for draw/layout functions. */
            Util.safe = function safe(fn, label) {
                try { return (typeof fn === "function") ? fn() : undefined; }
                catch (err) {
                    const msg = `[${label}] ${err && err.message ? err.message : err}`;
                    console.error("[timeline:render]", label, err);
                    const bar = document.getElementById("debug-bar");
                    if (bar) { bar.style.display = "block"; bar.textContent = "Render error: " + msg; }
                }
            };

            /** Debounce helper. */
            Util.debounce = function debounce(fn, ms) {
                let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
            };

            /** Perf timer: logs only when debug (?debug=1) is on. */
            Util.timed = function timed(label, fn) {
                const t0 = performance.now();
                const out = fn();
                const t1 = performance.now();
                if (window.__DBG__) console.log(`[perf] ${label}: ${(t1 - t0).toFixed(1)} ms`);
                return out;
            };

            /** Clamp helper. */
            Util.clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

            Util.textHaloOffset = function (yEvt, yFoc) {
                const R = 40, MAX = 8;
                const dy = yEvt - yFoc, ady = Math.abs(dy);
                if (ady <= 1 || ady >= R) return 0; // v48.fix: snap-to-zero near anchor (≤1 px)
                const t = 1 - ady / R;
                return Math.sign(dy) * Math.round(MAX * Math.pow(t, 1.0));
            };

            // ---------------- Card text helpers (pure, DOM-free) ----------------

            /** Preferred display label for an event (falls back to 'label'). */
            Util.eventLabel = function (ev) {
                return (ev?.display_label || ev?.label || '').toString();
            };

            /** One-line meta string (e.g., year + theme if present). */
            Util.eventMeta = function (ev) {
                // Prefer preformatted "when" text (Finnish), then "ago", then raw year.
                const when = (ev?.display_when || ev?.display_ago || (ev?.year ?? '').toString());
                const theme = ev?.theme ? `Theme: ${ev.theme}` : null; // keep label in English for now
                return [when, theme].filter(Boolean).join(' · ');
            };
            // Build the event title text for labels on the timeline.
            // Uses precomputed display_when/display_ago; falls back to plain label.
            // Never shows empty parentheses.
            Util.eventTitle = function (ev) {
                const base = Util.eventLabel(ev);
                const when = (ev?.display_when || ev?.display_ago || '').toString().trim();
                return when ? `${base} (${when})` : base;
            };
            // Build short event title for on-chart labels: use ONLY relative time.
            // Never shows empty parentheses.
            Util.eventTitleShort = function (ev) {
                const base = Util.eventLabel(ev);
                const ago = (ev?.display_ago || '').toString().trim();
                return ago ? `${base} (${ago})` : base;
            };

            /** Safe truncation with ellipsis; avoids breaking short strings. */
            Util.truncate = function (str, max = 60, suffix = '…') {
                const s = (str ?? '').toString();
                if (max <= 0) return '';
                if (s.length <= max) return s;
                // preserve word boundary if possible
                const cut = s.slice(0, max - suffix.length);
                const ws = cut.lastIndexOf(' ');
                return (ws >= 24 ? cut.slice(0, ws) : cut) + suffix;
            };
            // --- Card metrics (pure, DOM-free except bbox reads) ---
            // Computes paddings and rect based on measured text heights.
            Util.cardMetrics = function (titleSel, groupSel, yTopEv, yBotEv, viewH) {
                const titleH = Math.ceil((() => { try { return titleSel.node().getBBox().height; } catch { return 10; } })()) || 10;
                const tmp = groupSel.append("text").attr("class", "event-label").attr("visibility", "hidden").text("X");
                const evH = Math.ceil((() => { try { return tmp.node().getBBox().height; } catch { return 9; } })()) || 9;
                tmp.remove();

                const topPad = titleH + 6;
                const botPad = Math.ceil(evH * 2.2) + 8;
                const yRect = Math.min(yTopEv, yBotEv) - topPad;
                const hRect = Math.abs(yBotEv - yTopEv) + topPad + botPad;

                const fullyAbove = (yRect + hRect) < 15;
                const fullyBelow = yRect > viewH;

                return { topPad, botPad, yRect, hRect, fullyAbove, fullyBelow };
            };

            window.Util = Util;
        })();
    </script>
    <script>
        // -----------------------------------------------------------
        // TS_CFG / TS_DELAY
        // Global configuration objects used by timeline.js
        // Keep them here so values are easy to tweak without touching JS files.
        // -----------------------------------------------------------
        window.TS_CFG = {
            // Margins for the timeline viewport (pixels)
            margin: { top: 12, right: 54, bottom: 12, left: 54 },

            // Right-side zoom bar dimensions
            zoomBar: { width: 22, gap: 10 },

            // Event card layout parameters
            card: { minW: 160, pad: 10 },

            // Color palette used for event themes
            palette: ["#6372b2ff", "#70a8c6", "#4b9fa8", "#368d60ff", "#5a9646ff"],

            // Prefocus halo behavior (for focus highlight transitions)
            prefocus: { radiusPx: 16, hysteresisPx: 8 }
        };

        // Global timing delays for UI interactions (ms)
        window.TS_DELAY = { ACTIVATE: 1000, ZOOM: 1500 };
    </script>

    <script>
        // -----------------------------------------------
        // SwipeZoom module: handles touch and mouse gestures for zooming and panning
        // Horizontal swipe in center area → zoom in/out
        // Vertical swipe outside center area → pan up/down
        // This replaces the old setupGlobalSwipeZoom() in timeline.js
        // -----------------------------------------------
        (function () {
            /**
             * Attach gesture handling to an SVG element.
             * @param {d3.Selection} svgSel - the d3 selection for main SVG
             * @param {d3.ZoomBehavior} zoomBehavior - the D3 zoom behavior already created
             * @param {object} opts - optional parameters
             *   innerHeight: function returning window height (used to detect center zone)
             */
            function attach(svgSel, zoomBehavior, opts) {
                const innerHeight = (opts && opts.innerHeight) || (() => window.innerHeight);

                // --- gesture tuning constants ---
                const DEAD = 3;              // minimal movement before mode is decided
                const DOM_RATIO = 1.5;       // horizontal dominance threshold
                const SENS_TOUCH = -0.006;   // zoom sensitivity for touch
                const SENS_MOUSE = -0.003;   // zoom sensitivity for mouse
                const STEP = 20;             // max delta per frame
                const CLAMP_MIN = 0.95;      // minimal scale per step
                const CLAMP_MAX = 1.05;      // maximal scale per step

                // --- internal state ---
                let active = false;          // pointer currently down
                let mode = null;             // 'zoom' | 'pan' | null
                let startX = 0, startY = 0, lastX = 0, lastY = 0;
                let startInCenter = false;     // did gesture start in center zone?

                // --- helper: check if pointer Y is within the central zoom zone ---
                function inCenterZone(y) {
                    const H = innerHeight();
                    const zoneH = Math.max(80, Math.min(H * 0.36, 160)); // 80–160px or ~1/3 screen
                    const y0 = (H - zoneH) / 2, y1 = y0 + zoneH;
                    return y >= y0 && y <= y1;
                }

                const isTouch = (e) => e.pointerType === 'touch';
                const svgNode = svgSel.node();
                const contEl = document.getElementById('timeline-container');

                // --- visual feedback class toggle ---
                function setGestureActive(on) {
                    if (on) {
                        svgNode.classList.add('gesture-active');
                        if (contEl) contEl.classList.add('gesture-active');
                    } else {
                        svgNode.classList.remove('gesture-active');
                        if (contEl) contEl.classList.remove('gesture-active');
                    }
                }

                // -----------------------------------------------
                // pointerdown → start tracking
                // -----------------------------------------------
                svgNode.addEventListener('pointerdown', (e) => {
                    if (!e.isPrimary) return;        // ignore secondary touches
                    active = true; mode = null;
                    startX = lastX = e.clientX;
                    startY = lastY = e.clientY;
                    startInCenter = inCenterZone(e.clientY);
                    try { e.target.setPointerCapture(e.pointerId); } catch { }
                    e.stopPropagation();
                }, { passive: true, capture: true });

                // -----------------------------------------------
                // pointermove → decide mode and perform zoom/pan
                // -----------------------------------------------
                svgNode.addEventListener('pointermove', (e) => {
                    if (!active || !e.isPrimary) return;
                    const dxTot = e.clientX - startX;
                    const dyTot = e.clientY - startY;

                    // --- determine mode when movement passes threshold ---
                    if (mode === null && (Math.abs(dxTot) >= DEAD || Math.abs(dyTot) >= DEAD)) {
                        const horizDominates = (Math.abs(dxTot) > Math.abs(dyTot) * DOM_RATIO);
                        mode = (horizDominates && startInCenter) ? 'zoom' : 'pan';
                        setGestureActive(true);
                        window.__HAS_INTERACTED__ = true; // v47.5: first real gesture → allow prefocus later
                    }

                    // --- zoom mode ---
                    if (mode === 'zoom') {
                        const dxStep = Math.max(-STEP, Math.min(STEP, e.clientX - lastX));
                        if (Math.abs(dxStep) >= DEAD) {
                            lastX = e.clientX;
                            const sens = isTouch(e) ? SENS_TOUCH : SENS_MOUSE;
                            const factor = Math.max(CLAMP_MIN, Math.min(CLAMP_MAX, 1 + dxStep * sens));
                            // D3 handles scaling relative to pointer position
                            svgSel.call(zoomBehavior.scaleBy, factor, [e.clientX, e.clientY]);
                        }
                        e.stopPropagation();
                        return;
                    }

                    // --- pan mode ---
                    if (mode === 'pan') {
                        const dyStep = Math.max(-STEP, Math.min(STEP, e.clientY - lastY));
                        if (Math.abs(dyStep) >= DEAD) {
                            lastY = e.clientY;
                            svgSel.call(zoomBehavior.translateBy, 0, dyStep);
                        }
                        e.stopPropagation();
                        return;
                    }

                    e.stopPropagation();
                }, { passive: true, capture: true });

                // -----------------------------------------------
                // pointerup / cancel / lostcapture → reset
                // -----------------------------------------------
                const end = () => {
                    active = false; mode = null;
                    setGestureActive(false);
                };
                svgNode.addEventListener('pointerup', end, { passive: true, capture: true });
                svgNode.addEventListener('pointercancel', end, { passive: true, capture: true });
                svgNode.addEventListener('lostpointercapture', end, { passive: true, capture: true });
            }

            // Expose globally for timeline.js
            window.SwipeZoom = { attach };
        })();
    </script>
    <script>
        // -------------------------------------------------------
        // Ticks: compute major/minor tick values for a log domain
        // - majors: 10^n within [d0, d1]
        // - minors: 2..9 × 10^n within [d0, d1] (optional)
        // Keep this pure (no DOM), so it's easy to move to utils.js later.
        // -------------------------------------------------------
       (function () {
            // Stable decade ticks on zoom/pan:
            // - lower bound uses CEIL (push up to the next full decade)
            // - upper bound uses FLOOR (down to the previous full decade)
            // - tiny EPS avoids floating jitter exactly on boundaries (e.g. 1e-8 ± 1e-16)
            const EPS = 1e-12;

            function majorsFromDomain(d0, d1) {
                if (d0 > d1) [d0, d1] = [d1, d0];

                // guard against zeros/negatives in log scale
                d0 = Math.max(d0, Number.MIN_VALUE);
                d1 = Math.max(d1, d0);

                const n0 = Math.ceil(Math.log10(d0 * (1 + EPS)));
                const n1 = Math.floor(Math.log10(d1 * (1 - EPS)));

                const values = [];
                const exponents = [];
                for (let e = n0; e <= n1; e++) {
                    values.push(Math.pow(10, e));
                    exponents.push(e);
                }
                return { exponents, values };
            }

            function minorsFromDomain(d0, d1, showMinor) {
                if (!showMinor) return [];
                if (d0 > d1) [d0, d1] = [d1, d0];

                d0 = Math.max(d0, Number.MIN_VALUE);
                d1 = Math.max(d1, d0);

                const n0 = Math.ceil(Math.log10(d0 * (1 + EPS)));
                const n1 = Math.floor(Math.log10(d1 * (1 - EPS)));

                const out = [];
                for (let e = n0; e <= n1; e++) {
                    const base = Math.pow(10, e);
                    for (let m = 2; m <= 9; m++) {
                        const v = m * base;
                        if (v >= d0 && v <= d1) out.push(v);
                    }
                }
                return out;
            }

            window.Ticks = { majorsFromDomain, minorsFromDomain };
        })();

    </script>
    <script>
        // -------------------------------------------------------
        // CenterBand: pure math for the center zone geometry
        // Computes the vertical center line (midY), the zoom zone band (zoneY/zoneH),
        // and the horizontal endpoints (xLeft/xRight) for the center hairline.
        // Inputs are plain numbers; no DOM access here to keep it reusable.
        // -------------------------------------------------------
        (function () {
            /**
             * Compute geometry for the center band and hairline.
             * @param {number} w - svg width (outer)
             * @param {number} h - svg height (outer)
             * @param {number|NaN} axisRight - right edge (px) of the axis group, or NaN if unknown
             * @param {number|NaN} zoomBarLeft - left edge (px) of the zoom bar/track, or NaN if unknown
             * @returns {{zoneY:number, zoneH:number, midY:number, xLeft:number, xRight:number}}
             */
            function compute(w, h, axisRight, zoomBarLeft) {
                // Vertical band in the middle of the screen (used as "zoom allowed" zone)
                const zoneH = Math.max(80, Math.min(h * 0.36, 160)); // clamp 80–160 px
                const zoneY = (h - zoneH) / 2;
                const midY = Math.round(h / 2);

                // Horizontal endpoints: keep the hairline clear of axis and zoom bar
                const DEFAULT_LEFT_INSET = 14; // fallback padding from the left edge
                const DEFAULT_RIGHT_INSET = 4;  // fallback padding from the right edge
                const AXIS_GAP = 1;            // extra space after axis
                const ZOOMB_GAP = 15;           // extra space before zoom bar

                // Build endpoints with sensible fallbacks
                let xLeft = Number.isFinite(axisRight) ? Math.ceil(axisRight + AXIS_GAP) : DEFAULT_LEFT_INSET;
                let xRight = Number.isFinite(zoomBarLeft) ? Math.floor(zoomBarLeft - ZOOMB_GAP) : (w - DEFAULT_RIGHT_INSET);

                // Clamp to viewport
                xLeft = Math.max(0, Math.min(xLeft, w - DEFAULT_RIGHT_INSET));
                xRight = Math.max(DEFAULT_LEFT_INSET, Math.min(xRight, w));

                // If span is too short, relax a bit but stay reasonable
                const span = xRight - xLeft;
                if (span < w * 0.3) {
                    const leftRelax = Number.isFinite(axisRight) ? Math.min(axisRight + AXIS_GAP, 40) : 0;
                    const rightRelax = Number.isFinite(zoomBarLeft) ? Math.min((w - zoomBarLeft) + ZOOMB_GAP, 40) : 0;
                    xLeft = DEFAULT_LEFT_INSET + leftRelax;
                    xRight = w - DEFAULT_RIGHT_INSET - rightRelax;
                }

                // Final safety: ensure at least a minimal centered segment
                if ((xRight - xLeft) < 24) {
                    const cx = Math.round(w / 2);
                    xLeft = cx - 12;
                    xRight = cx + 12;
                }

                return { zoneY, zoneH, midY, xLeft, xRight };
            }

            // Expose as a tiny module
            window.CenterBand = { compute };
        })();
    </script>
<script>
    // -------------------------------------------------------
    // DataUtil: normalizeData()
    // Preprocesses loaded eventsDB.json:
    //  - merges group.theme into each event
    //  - applies i18n labels for the chosen language (from metadata.locale_default)
    //  - extracts theme order and colors from metadata.ui
    // -------------------------------------------------------
    (function () {
        function normalizeData(data, langFromCaller) {
            // Read from 'metadata' (the actual key in eventsDB.json)
            const meta = data.metadata || {};
            const ui = meta.ui || {};
            const themeOrder = Array.isArray(ui.themeOrder) ? ui.themeOrder : null;
            const themeColors = ui.themeColors || null;

            // Choose language: caller can pass one, otherwise use metadata.locale_default
            const lang = langFromCaller || meta.locale_default || "fi";

            // Flatten groups → inject theme into each event and build display_label/comments
            const events = (data.events || []).flatMap(g =>
                (g.events || []).map(e => ({
                    ...e,
                    theme: g.theme,
                    display_label:
                        (e.i18n && e.i18n[lang] && e.i18n[lang].label)
                            ? e.i18n[lang].label
                            : e.label,
                    display_comments:
                        (e.i18n && e.i18n[lang] && e.i18n[lang].comments)
                            ? e.i18n[lang].comments
                            : (e.comments || "")
                }))
            );

            // Derive themes, respecting metadata.ui.themeOrder when present
            const themes = themeOrder
                ? themeOrder.filter(t => events.some(e => e.theme === t))
                : Array.from(new Set(events.map(e => e.theme)));

            return { events, themes, themeColors, langUsed: lang };
        }

        // Expose globally for timeline.js
        window.DataUtil = { normalizeData };
    })();
</script>
<script>
    /* ----------------------------------------------------------
       v45.1 — Data preparation and absolute "present" events
       ----------------------------------------------------------
       This script moves data loading from timeline.js to index.html.
       It:
       1. Fetches eventsDB.json and metadata.
       2. Normalizes via DataUtil.normalizeData (already loaded).
       3. Anchors "present" events to the real wall clock time.
       4. Exposes the combined data as window.TS_DATA for timeline.js.
       ---------------------------------------------------------- */

    (function () {
        /* --- Time utilities (candidates for utils/timeUtils.js) --- */

        const YEAR_MS = 365.2425 * 24 * 3600 * 1000;
        const yearsBetween = (a, b) => Math.abs(b - a) / YEAR_MS;

        const floorToSecond = d => (d = new Date(d), d.setMilliseconds(0), d);
        const floorToMinute = d => (d = new Date(d), d.setSeconds(0, 0), d);
        const floorToHour = d => (d = new Date(d), d.setMinutes(0, 0, 0), d);
        const floorToDay = d => (d = new Date(d), d.setHours(0, 0, 0, 0), d);

      /* --- Build present anchors (stable header + trailing seconds + fixed intervals) --- */
        function buildPresent(now = new Date()) {
            const MSY = 31557600 * 1000;      // ms per tropical year
            const SEC_TO_YEARS = 1 / 31557600;
            const THIS_SEC_EPS = SEC_TO_YEARS * 0.02;   // ~20 ms safety gap
            const USE_FIXED_ONE_SEC = true;

            const items = [];

            // --- helpers ---
            const tNowRaw = Date.now();
            // Quantize to whole seconds so multiple refresh paths (1 Hz + render) see identical “now”
            const tNow = Math.floor(tNowRaw / 1000) * 1000;

            const withinSec = (tNow % 1000) / 1000;
            const thisSecAgeSec = USE_FIXED_ONE_SEC ? 1.0 : Math.max(0.1, withinSec);
            const thisSecYears = thisSecAgeSec * SEC_TO_YEARS;

            // --- small reference anchors ---
            const REF_0_1S_YEARS = 0.1 * SEC_TO_YEARS;
            const ONE_MIN_YEARS = 60 * SEC_TO_YEARS;
            const ONE_HOUR_YEARS = 3600 * SEC_TO_YEARS;
            const ONE_DAY_YEARS = 86400 * SEC_TO_YEARS;
            const ONE_MONTH_YEARS = 1 / 12;
            const ONE_YEAR_YEARS = 1;

            // helper for label text  (formats nicely)
            function fmtAgo(secs) {
                if (secs < 1) return `${secs.toFixed(1)} s ago`;
                if (secs < 60) return `${secs.toFixed(0)} s ago`;
                if (secs < 3600) return `${(secs / 60).toFixed(0)} min ago`;
                if (secs < 86400) return `${(secs / 3600).toFixed(0)} h ago`;
                if (secs < 2592000) return `${(secs / 86400).toFixed(0)} d ago`;
                if (secs < 31557600) return `${(secs / 2592000).toFixed(0)} mo ago`;
                return `${(secs / 31557600).toFixed(0)} y ago`;
            }

            // ─────────────────────────────────────────────
            // 1) "this sec" shows next clock second, labeled "(time 1 s ago)"
            const nextDate = new Date(now.getTime() + 1000); // +1 second ahead
            const nextTime = nextDate.toTimeString().slice(0, 8);
            items.push({
                theme: 'present',
                label: `${nextTime} (time 1 s ago)`,
                time_years: thisSecYears
            });

            // ─────────────────────────────────────────────
            // 2) short reference (0.1 s ago) — place slightly *above* “this sec”
            items.push({
                theme: 'present',
                label: fmtAgo(0.1),
                time_years: Math.min(thisSecYears - THIS_SEC_EPS, REF_0_1S_YEARS)
            });

            // ─────────────────────────────────────────────
            // 3) Deterministic trail from a single post-load 5 s anchor (no per-marker state)

            // 3.1) asetetaan pysyvä ensimmäinen 5 s raja: vasta sivulatauksen JÄLKEINEN raja
            if (typeof window.__first5sAnchorMs === 'undefined') {
                const bucketAtLoad = Math.floor(tNow / 5000);
                const bucketNow = Math.floor(tNow / 5000);
                // Ei vielä luoda ankkuria; odotetaan että ylitetään seuraava 5 s -raja
                window.__first5sAnchorMs = null;
                window.__first5sLoadBucket = bucketAtLoad;
            }
            // jos rajaa ei vielä ole ja on ylitetty seuraava 5 s -bucket, lukitaan se
            if (window.__first5sAnchorMs === null) {
                const bucketNow = Math.floor(tNow / 5000);
                if (bucketNow > window.__first5sLoadBucket) {
                    window.__first5sAnchorMs = bucketNow * 5000; // täsmälleen …:50/…:55/…:00/…
                }
            }

            const firstAnchor = window.__first5sAnchorMs;

            if (typeof firstAnchor === 'number') {
                // 3.2) lasketaan kaikki 5 s -ankkurit välillä [firstAnchor, tNow]
                // i = 0 on ensimmäinen ankkuri, i kasvaa yhdellä jokaisesta 5 s rajasta
                const n = Math.floor((tNow - firstAnchor) / 5000); // 0..N
                for (let i = 0; i <= n; i++) {
                    const anchor = firstAnchor + i * 5000;  // tämän markkerin syntyhetki (5 s raja)

                    // markkerin ikä: alkaa 2 s:sta ja kasvaa 1 s/s
                    const ageSec = 2 + (tNow - anchor) / 1000;

                    // Integroitunut ikä (kokonaisluvuksi), käyttöön vain näkyvyyskriteeriin
                    const ageInt = Math.floor(ageSec + 1e-9);

                    // 3.3) näkyvyys/kuolema:
                    //  - näytä kaikki kun ikä < 15 s
                    //  - 15–45 s: näytä tasan 15:n monikerrat (15, 30)
                    //  - ≥ 45 s: älä näytä mitään
                    if (ageInt >= 45) continue;
                    if (ageInt < 45 && (ageInt < 15 || ageInt % 15 === 0)) { /* näkyvä */ }
                    else continue;

                    // 3.4) labelin kellonaika on syntyankkuri (…:50/…:55/…:00/…), "ago" on ageInt
                    const labelStr = new Date(anchor).toTimeString().slice(0, 8);

                    items.push({
                        theme: 'present',
                        label: `${labelStr} (${fmtAgo(ageInt)})`,
                        // sijainti käyttää jatkuvaa aikaa; pieni ε pitää sen “this sec” -viivan alla
                        time_years: Math.max(thisSecYears + THIS_SEC_EPS, ageSec * SEC_TO_YEARS)
                    });
                    // DEBUG (poista kun ok):  console.log('trail', { i, anchor, ageSec: ageSec.toFixed(2), ageInt });
                }
            }

            // ─────────────────────────────────────────────
            // 4) fixed larger intervals
            const FIXED = [
                { secs: 60, years: ONE_MIN_YEARS },
                { secs: 3600, years: ONE_HOUR_YEARS },
                { secs: 86400, years: ONE_DAY_YEARS },
                { secs: 2592000, years: ONE_MONTH_YEARS },
                { secs: 31557600, years: ONE_YEAR_YEARS }
            ];
            for (const f of FIXED) {
                items.push({
                    theme: 'present',
                    label: fmtAgo(f.secs),
                    time_years: Math.max(thisSecYears + THIS_SEC_EPS, f.years)
                });
            }

            // ensure chronological order (newest → oldest)
            items.sort((a, b) => a.time_years - b.time_years);
            return items;
        }

        // expose for realtime updater
        window.buildPresent = buildPresent;
        const THEME_ORDER_5 = ["kosmos", "biologia", "ihmiskunta", "historia", "moderni teknologia"];

        function decimalYearFromDate(d) {
            const Y = d.getFullYear();
            const a = new Date(Y, 0, 1), b = new Date(Y + 1, 0, 1);
            return Y + (d - a) / (b - a);
        }
        function ageYearsFromISODate(iso, nowMs) {
            const t = Date.parse(iso);
            if (!Number.isFinite(t)) return NaN;
            return (nowMs - t) / (365.2425 * 24 * 3600 * 1000);
        }
                // --- Finnish "ago" formatter for display fields (no DB changes) ---
        // Converts age in years -> human readable "ago" text + unit selection.
        function formatAgoFi(ageYears) {
            const y = Math.max(0, +ageYears || 0); // guard

            const SEC_PER_YEAR = 31557600;
            const s = y * SEC_PER_YEAR;

            // sub-year ranges by natural units
            if (s < 90) {
                const n = Math.round(s);
                return { value: n, unit: 's', text: `${n} s sitten` };
            }
            if (s < 90 * 60) {
                const n = Math.round(s / 60);
                return { value: n, unit: 'min', text: `${n} min sitten` };
            }
            if (s < 36 * 3600) {
                const n = Math.round(s / 3600);
                return { value: n, unit: 'h', text: `${n} h sitten` };
            }
            if (s < 90 * 86400) {
                const n = Math.round(s / 86400);
                return { value: n, unit: 'd', text: `${n} d sitten` };
            }
            if (y < 1.5) {
                const n = Math.round(y * 12);
                return { value: n, unit: 'kk', text: `${n} kk sitten` };
            }
            if (y < 950) {
                const n = Math.round(y);
                return { value: n, unit: 'v', text: `${n} v sitten` };
            }
            if (y < 950_000) {
                const n = Math.round(y / 1_000);
                // Optionally "ka" for abbreviated scientific style; we keep plain Finnish.
                return { value: n, unit: 'tuhat v', text: `${n} t. v sitten` };
            }
            if (y < 950_000_000) {
                const raw = y / 1_000_000;
                const n = (raw < 10) ? Math.round(raw * 10) / 10 : Math.round(raw);
                return { value: n, unit: 'milj. v', text: `${n} milj. v sitten` };
            }
            // billions of years
            const raw = y / 1_000_000_000;
            const n = (raw < 10) ? Math.round(raw * 10) / 10 : Math.round(raw);
            return { value: n, unit: 'mrd v', text: `${n} mrd v sitten` };
        }
        // --- Robust year parser (handles number or string; tolerates BCE/eaa forms) ---
        // Accepts: 2020, "2020", "-27", "−27", "27 BCE", "27 eaa", "563 eKr", etc.
        // Returns: finite Number (negative for BCE) or NaN if not parseable.
        function parseYearFlexible(y) {
            if (typeof y === "number" && Number.isFinite(y)) return y;
            if (typeof y !== "string") return NaN;

            let s = y.trim().toLowerCase();

            // Normalize Unicode minus/en dash to ASCII hyphen
            s = s.replace(/[\u2212\u2013\u2014]/g, "-");

            // Detect BCE markers in Finnish/English and flip sign if needed
            // (eaa = "ennen ajanlaskun alkua"; e.kr. variants; bce)
            const hasBce = /\b(eaa|e\.?kr|bce)\b/.test(s);

            // Remove non-digit markers/words (keep sign and digits)
            // e.g. "27 eaa" -> "27", "563 eKr" -> "563"
            const m = s.match(/^-?\d+(\.\d+)?/);
            if (!m) return NaN;

            let n = parseFloat(m[0]);
            if (hasBce && n > 0) n = -n;

            return Number.isFinite(n) ? n : NaN;
        }

        // Absolute time pretty-print:
        // - prefer ISO date YYYY-MM-DD if available
        // - otherwise use a clean year string when sensible
        function buildDisplayAbs(src) {
            const y = parseYearFlexible(src?.year);
            if (Number.isFinite(y)) {
                // Keep a simple, neutral absolute form (no BCE suffix change now).
                // If you later want Finnish "eaa" here, we can switch to that.
                return String(Math.round(y));
            }
            if (typeof src?.date === 'string' && src.date.length >= 10) {
                return src.date.slice(0, 10); // "YYYY-MM-DD"
            }
            return '';
        }

        async function prepare() {
            try {
                // 1) Lataa uusi formaatti (meta + flat events)
                const res = await fetch('eventsDB45.json', { cache: 'no-store' });
                if (!res.ok) throw new Error('eventsDB45.json not found');
                const json = await res.json();

                // 2) Lue meta + värit
                const meta = json.meta || {};
                const themeDefs = meta.themes || {};

                // Rakenna themeColors metasta; fallbackit jos väri puuttuu
                const FALLBACK = ["#6372b2", "#70a8c6", "#4b9fa8", "#368d60", "#5a9646"];
                const themeColors = {};
                let i = 0;
                for (const t of Object.keys(themeDefs)) {
                    const c = (themeDefs[t] && themeDefs[t].color) || FALLBACK[Math.min(i, FALLBACK.length - 1)];
                    themeColors[t] = c; i++;
                }

                // 3) Teemajärjestys: ytimet ensin, sitten mahdolliset muut datassa
                const themesInData = Array.from(new Set((json.events || []).map(e => e.theme).filter(Boolean)));
                const themeOrder = THEME_ORDER_5.filter(t => themesInData.includes(t))
                    .concat(themesInData.filter(t => !THEME_ORDER_5.includes(t)));

                // 4) Laske time_years (ikä vuosina) uuteen skaalaan (ei DataUtil.normalizeDataa)
                const now = new Date();
                const nowMs = now.getTime();
                const nowDec = decimalYearFromDate(now);

                const baseEvents = (json.events || []).map(src => {
                    // Prefer 'year' (even if positive) over 'date' for age calculation.
                    // Accept year both as number and as string (BCE/eaa allowed).
                    const yearNum = parseYearFlexible(src.year);

                    let ageYears = NaN;
                    if (Number.isFinite(yearNum)) {
                        // From decimal year: nowDec - year
                        ageYears = nowDec - yearNum;
                    } else if (typeof src.date === "string") {
                        const t = Date.parse(src.date);
                        if (Number.isFinite(t)) {
                            ageYears = (nowMs - t) / (365.2425 * 24 * 3600 * 1000);
                        }
                    }

                    // Drop future events only (ageYears <= 0)
                    if (!Number.isFinite(ageYears) || ageYears <= 0) return null;

                    // jätä tulevaisuus pois (≤ 0)
                    if (!Number.isFinite(ageYears) || ageYears <= 0) return null;
                    // Compute preformatted Finnish display fields for the renderer
                    const ago = formatAgoFi(ageYears);
                    const display_abs = buildDisplayAbs(src);
                    const display_when = display_abs ? `${display_abs} · ${ago.text}` : ago.text;

                    return {
                        theme: src.theme,
                        id: src.id,
                        label: src.label,
                        display_label: src.label, // keep for UI
                        year: (typeof src.year === "number") ? src.year : undefined,
                        date: (typeof src.date === "string") ? src.date : undefined,

                        // relative age basis for layout
                        time_years: ageYears,

                        // NEW: pre-formatted display fields (Finnish)
                        ago_value: ago.value,
                        ago_unit: ago.unit,
                        display_ago: ago.text,
                        display_abs,
                        display_when,

                        author: src.author || "ChatGPT",
                        edit_date: src.edit_date || "2025-10-20",
                        info: src.info,
                        ref: src.ref,
                        language: src.language || meta.language || "fi"
                    };
                }
            ).filter(Boolean)
                    .sort((a, b) => b.time_years - a.time_years);

                // 5) Present-overlayn ankkurit (käytetään jo olemassa olevaa buildPresent()ia)
                const present = buildPresent().sort((a, b) => a.time_years - b.time_years);

                // 6) Yhdistä ja lisää present-teeman väri
                const merged = baseEvents.concat(present);
                const outThemes = Array.from(new Set([...themeOrder, 'present']));
                const outThemeColors = Object.assign({ present: '#ff8c42' }, themeColors);

                // 7) Publish for timeline.js — allow editor-owned preview merge
                // EN: Keep a copy of the pure base pack to support re-merge after editor changes.
                const basePack = { meta, events: merged, themes: outThemes, themeColors: outThemeColors };
                window.__BASE_PACK = basePack;  // <-- store pristine base (without preview drafts)

                // EN: Initial TS_DATA visible at first paint
                window.TS_DATA = (window.PreviewData && typeof PreviewData.merge === 'function')
                    ? PreviewData.merge(basePack)
                    : basePack;

                console.info('[v47.2] TS_DATA prepared:', window.TS_DATA);

            } catch (e) {
                console.warn('[v45.4] prepare() failed, fallback to present-only:', e);
                const present = buildPresent().sort((a, b) => a.time_years - b.time_years);
                window.TS_DATA = { events: present, themes: ['present'], themeColors: { present: '#ff8c42' } };
            }
        }

        // Promise allows timeline.js to wait if needed
        window.TS_DATA_P = prepare();
    })();
</script>

<script>
    /* EN: Rebuild TS_DATA from the pristine base + current PreviewData drafts, then soft-refresh the timeline. */
    window.rerenderTimeline = function rerenderTimeline() {
        try {
            if (!window.__BASE_PACK) return; // base not ready yet
            const pack = (window.PreviewData && typeof PreviewData.merge === 'function')
                ? PreviewData.merge(window.__BASE_PACK)    // base + drafts
                : window.__BASE_PACK;                      // fallback: base only

            window.TS_DATA = pack;                       // publish
            if (typeof window.updateTimeline === 'function') {
                window.updateTimeline();                   // soft re-draw (keeps zoom/scroll)
            }
        } catch (err) {
            console.warn('[rerenderTimeline] failed:', err);
        }
    };
</script>

<script>
    /* PrefocusInfo — armed-after-motion model (v47.6)
       - Opens only if:
         1) not disabled, AND
         2) "armed" (i.e., there was viewport motion and it has settled for ARM_QUIET_MS)
       - Any UI click outside the SVG should disarm (added in block #2).
    */
    (function () {
        const OPEN_DELAY_MS = 600;       // dwell before opening in prefocus
        const REOPEN_DELAY_MS = 900;     // min time between openings
        const ARM_QUIET_MS = 350;        // quiet time after motion before we arm

        let dwellTimer = null;
        let armTimer = null;
        let lastShownTop = NaN;      // v48: popup guard anchor (screen Y of last shown box)

        let armed = false;               // becomes true only after viewport motion settles
        let disabled = false;            // set true while help panel (or other modal) is open
        let lastKey = null;
        let lastOpenAt = 0;

        function cancel() {
            if (dwellTimer) { clearTimeout(dwellTimer); dwellTimer = null; }
        }

        function disarm() {
            armed = false;                 // require fresh motion before any next popup
            cancel();
            if (window.InfoBox && InfoBox.hide) InfoBox.hide();
        }

        function setDisabled(on) {
            disabled = !!on;
            if (disabled) disarm();
        }

        // Called repeatedly by timeline.js during/after zoom/pan renders
        function onViewportMotion() {
            // Any motion cancels dwell and disarms immediately.
            cancel();
            if (window.InfoBox) InfoBox.hide();
            armed = false;

            // Re-arm only after motion has been quiet for ARM_QUIET_MS
            if (armTimer) clearTimeout(armTimer);
            armTimer = setTimeout(() => { armed = true; }, ARM_QUIET_MS);
        }

        // Called by timeline.js after each render with the current prefocus key
        // resolver() => { box: DOMRect, data: eventObj } or null
        function onPrefocus(key, resolver) {
            // If disabled or not armed yet, ignore silently
            if (disabled || !armed) return;

            // Focus left → cancel any pending dwell + hide
            if (!key) { cancel(); if (window.InfoBox) InfoBox.hide(); lastKey = null; return; }

            // Same target & already waiting → do nothing
            if (key === lastKey && dwellTimer) return;

            cancel();
            lastKey = key;
            const now = performance.now();
            const wait = Math.max(OPEN_DELAY_MS, (lastOpenAt + REOPEN_DELAY_MS) - now);

            dwellTimer = setTimeout(() => {
                dwellTimer = null;
                try {
                    const r = (typeof resolver === 'function') ? resolver() : null;
                    if (!r || !r.box || !r.data) return;
                    if (window.InfoBox && InfoBox.show) {
                        const top = Math.round(r.box.top || 0);
                        const GUARD = 5; // v48: dead-band for popup re-open
                        // If movement since last show is tiny, skip re-open to avoid flicker
                        if (Number.isFinite(lastShownTop) && Math.abs(top - lastShownTop) <= GUARD) {
                            return;
                        }
                        InfoBox.show(r.data, r.box);
                        lastShownTop = top;  // remember last anchor position
                        lastOpenAt = performance.now();
                    }
                } catch { }
            }, wait);
        }

        window.PrefocusInfo = { onPrefocus, onViewportMotion, cancel, disarm, setDisabled };
    })();
</script>

<script>
    /* Info toggle — close with Esc or any outside interaction (v47.7) */
    (function () {
        const btn = document.getElementById("info-toggle");
        const panel = document.getElementById("info-box");
        let helpActive = false;

        function setHelp(on) {
            const next = !!on;
            helpActive = next;
            panel.style.display = next ? "block" : "none";
            btn.classList.toggle("active", next);

            // While help is open, disable prefocus; on close, require fresh motion
            if (window.PrefocusInfo) {
                PrefocusInfo.setDisabled(next);
                PrefocusInfo.disarm();
            }
            if (window.InfoBox && InfoBox.hide) InfoBox.hide();
        }

        // Toggle by button
        btn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            setHelp(!helpActive);
        });

        // Do NOT close when interacting inside the panel
        panel.addEventListener("click", (e) => e.stopPropagation(), { capture: true });
        panel.addEventListener("pointerdown", (e) => e.stopPropagation(), { capture: true });

        // Close on ESC from anywhere
        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && helpActive) setHelp(false);
        });

        // Close on ANY interaction outside the help panel (including SVG/timeline)
        // Use pointerdown in capture phase so it wins over other handlers.
        document.addEventListener("pointerdown", (ev) => {
            if (!helpActive) return;

            const t = ev.target;
            // clicks on the toggle button or inside the panel should not close
            if (t === btn || panel.contains(t)) return;

            setHelp(false);
        }, { capture: true, passive: true });

        // Close on any timeline render (zoom/pan triggers a render)
        document.addEventListener("timeline:render", () => {
            if (helpActive) setHelp(false);
        });
    })();
</script>

<script>
    /* v45.9 — Present theme live updater (simplified & stable)
       - Refreshes the “present” layer once per second.
       - Starts automatically when the intro animation completes.
       - Also refreshes immediately after any zoom/scroll render.
    */
    (function () {
        function refreshPresent(nowDate) {
            const present = (typeof buildPresent === 'function')
                ? buildPresent(nowDate).sort((a, b) => a.time_years - b.time_years)
                : [];
            const base = (window.TS_DATA?.events || []).filter(e => e.theme !== 'present');
            window.TS_DATA = Object.assign({}, window.TS_DATA, { events: base.concat(present) });
            // v47.8: flag that this redraw was triggered by the 1 s present loop (not user motion)
            window.__PRESENT_TICK__ = Date.now();
            if (typeof window.updateTimeline === 'function') window.updateTimeline();
        }

        let lastS = -1;
        function loop() {
            const t = Date.now(), s = Math.floor(t / 1000);
            if (s !== lastS) { lastS = s; refreshPresent(new Date(t)); }
            requestAnimationFrame(loop);
        }

        function startPresentLoop() {
            if (window.__presentLoopStarted) return;
            window.__presentLoopStarted = true;
            refreshPresent(new Date());
            requestAnimationFrame(loop);
        }

        // Start automatically when the intro animation finishes
        document.addEventListener('timeline:intro-done', startPresentLoop, { once: true });
    })();
</script>

<!-- modules in files -->
<script src="editor.js"></script>
<script src="timeline.js"></script>
</body>

</html>