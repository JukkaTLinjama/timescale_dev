<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
        <title>History Timeline v42</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link rel="stylesheet" href="style.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <h1 id="page-title">
        History at your fingertips — Big Bang to 2025
        <span style="font-size:0.65em; color:#9e9d9d;">v42</span>
    </h1>

    <div id="info-toggle">?</div>
<div id="info-box" style="display:none;">
    <div id="help-message">
        <p><em>Experimental visualization</em> of history across an immense time span.</p>
        <p>A vertical, <em>zoomable logarithmic timeline</em> of key events from the Big Bang to the present
            (2025).</p>
        <p>Events are grouped into <em>partly overlapping themes</em> that you can bring to the front.</p>

        <hr style="border:none; border-top:1px solid #ddd; margin:8px 0;">
        <!-- pikavinkit -->
        <p><em>Tips:</em> Pinch/scroll content or swipe L/R to zoom · Click a theme card to focus · Tap an event
            for notes</p>
    </div>

    <!-- status päivittyy skriptistä -->
    <div id="status-message" style="font-size:0.75em; color:#666; margin-top:2px;">
        Loading…
    </div>

    <!-- erillinen author-kenttä, EI muutu skriptissä -->
    <div id="author" style="font-size:0.75em; color:#666; margin-top:6px;">
        Authors: Jukka Linjama &amp; ChatGPT 5.0. 
    </div>

    <div id="license-info" style="font-size:0.7em; color:#666; margin-top:6px;">
        Project in <a href="https://github.com/JukkaTLinjama/log-aikajana" target="_blank">Github</a>
        Shared as an <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>
        experiment.<br>
        Enjoy &amp; share!
    </div>
</div>

    <div id="timeline-container">
        <svg id="timeline"></svg>
    </div>

    <div id="page-footer">© 2025 JL · CC BY 4.0</div>

    <script>
        // Debug switch via ?debug=1
        (function () {
            const u = new URL(location.href);
            const dbg = u.searchParams.get("debug") === "1";
            // näkyvä pieni virhepalkki vain debug-tilassa
            if (dbg) {
                const bar = document.createElement("div");
                bar.id = "debug-bar";
                bar.style.cssText = "position:fixed;left:0;right:0;bottom:0;z-index:99999;font:12px/1.4 system-ui;padding:6px 10px;background:#300;color:#fdd;display:none";
                bar.textContent = "Debug on. Errors will appear here.";
                document.addEventListener("DOMContentLoaded", () => document.body.appendChild(bar));
                window.__DBG__ = true;
                window.addEventListener("error", (e) => {
                    bar.style.display = "block";
                    bar.textContent = "Error: " + (e.message || "unknown");
                    console.error("[timeline:error]", e.message, e.error);
                });
                window.addEventListener("unhandledrejection", (e) => {
                    bar.style.display = "block";
                    bar.textContent = "Promise error: " + (e.reason && (e.reason.message || e.reason));
                    console.error("[timeline:promise]", e.reason);
                });
                console.log("%c[debug] enabled", "color:#9f9");
            }
        })();
    </script>

    <!-- Lightweight helpers (no side effects). Loaded before timeline.js -->
    <script>
        (function () {
            if (window.Util) return; // avoid double-load
            const Util = {};

            /** Try/catch wrapper for draw/layout functions. */
            Util.safe = function safe(fn, label) {
                try { return (typeof fn === "function") ? fn() : undefined; }
                catch (err) {
                    const msg = `[${label}] ${err && err.message ? err.message : err}`;
                    console.error("[timeline:render]", label, err);
                    const bar = document.getElementById("debug-bar");
                    if (bar) { bar.style.display = "block"; bar.textContent = "Render error: " + msg; }
                }
            };

            /** Debounce helper. */
            Util.debounce = function debounce(fn, ms) {
                let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
            };

            /** Perf timer: logs only when debug (?debug=1) is on. */
            Util.timed = function timed(label, fn) {
                const t0 = performance.now();
                const out = fn();
                const t1 = performance.now();
                if (window.__DBG__) console.log(`[perf] ${label}: ${(t1 - t0).toFixed(1)} ms`);
                return out;
            };

            /** Clamp helper. */
            Util.clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

            window.Util = Util;
        })();
    </script>

    <script src="timeline.js"></script>
    
    <script>     // Startup animation: ---------------------------------------------
        const nav = performance.getEntriesByType('navigation')[0];
            if (nav && nav.type === 'reload') {
                sessionStorage.removeItem('startup_v41_shown');
            }

        (function(){
            function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // --- Touch cursor helpers (Chrome DevTools -tyylinen pallo) ---
    function ensureTouchCursor(){
                let el = document.getElementById('touch-cursor');
            if(!el){
                el = document.createElement('div');
                el.id = 'touch-cursor';
                // inline style backup (jos style.css puuttuu)
                el.style.cssText = [
                'position:fixed;width:18px;height:18px;border-radius:50%;',
                'background:rgba(255,255,255,0.95);',
                'box-shadow:0 0 0 10px rgba(255,255,255,0.10),0 1px 6px rgba(0,0,0,.35);',
                'z-index:1700;pointer-events:none;opacity:0;',
                'transform:translate(-9px,-9px);',
                'transition:opacity .20s ease,left .60s cubic-bezier(.2,.8,.2,1),top .60s cubic-bezier(.2,.8,.2,1);'
                ].join('');
                document.body.appendChild(el);
            }
        return el;
        }

        function moveTouchCursor(el, x, y, visible=true){
            el.style.left = x + 'px';
        el.style.top  = y + 'px';
        el.style.opacity = visible ? '1' : '0';
        }

        function moveTouchCursorInstant(el, x, y, visible = true) {
                const prev = el.style.transition;
                el.style.transition = 'opacity .20s ease, left 0s, top 0s';
                el.style.left = x + 'px';
                el.style.top = y + 'px';
                el.style.opacity = visible ? '1' : '0';
                void el.offsetWidth; // force layout so it "jumps"
                el.style.transition = prev || 'opacity .20s ease,left .60s cubic-bezier(.2,.8,.2,1),top .60s cubic-bezier(.2,.8,.2,1)';
        }

        function tapRipple(x,y){
            // kevyt "pulse" ilman riippuvuutta ulkoisesta CSS:stä
            const r = document.createElement('div');
                r.style.cssText = [
                'position:fixed;width:28px;height:28px;border-radius:50%;',
                'border:2px solid rgba(255,255,255,0.85);box-shadow:0 0 8px rgba(255,255,255,0.45);',
                'pointer-events:none;z-index:1699;opacity:0.85;',
                'transform:translate(-14px,-14px) scale(0.6);transition:transform .35s ease, opacity .35s ease;'
                ].join('');
                r.style.left = x + 'px';
                r.style.top  = y + 'px';
                document.body.appendChild(r);
            requestAnimationFrame(()=>{
                    r.style.transform = 'translate(-14px,-14px) scale(1.15)';
                r.style.opacity = '0';
            });
            setTimeout(()=>{ if(r.parentNode) r.parentNode.removeChild(r); }, 400);
        }

        function hideTouchCursor(el){
            if(!el) return;
                el.style.opacity = '0';
            setTimeout(()=>{ if(el.parentNode) el.parentNode.removeChild(el); }, 280);
        }

        // Etsi "ihmiskunta" otsikon ruutu-koordinaatti; fallback = TimelineAPI.getCenter()
        function findThemeCenter(theme){
            try{
            const svg = document.getElementById('timeline');
                if(!svg) return null;
                const titles = svg.querySelectorAll('text.card-title');
                for(const t of titles){
                if((t.textContent || '').trim().toLowerCase() === String(theme).toLowerCase()){
                const r = t.getBoundingClientRect();
                return {x: Math.round(r.left + r.width*0.5), y: Math.round(r.top + r.height*0.5) };
                }
            }
            } catch(_){ }
                return null;
        }

        // --- Startup sequence ---
        // Järjestys: tap "ihmiskunta" → 1s tauko → aloita 50px oikealta → zoom in +50% → out −20% → scroll up + down
        async function runStartup(){
        const api = window.TimelineAPI;
        if (!api) return;

        let cursor = ensureTouchCursor();

        // 1) Tap-select "ihmiskunta"
        const cTap = findThemeCenter('ihmiskunta') || api.getCenter();
        moveTouchCursor(cursor, cTap.x, cTap.y, true);
        await sleep(520);
        tapRipple(cTap.x, cTap.y);
        api.selectTheme('ihmiskunta');

        // tauko 1 s (touch irti)
        moveTouchCursor(cursor, cTap.x, cTap.y, false);
        await sleep(1000);

        // uusi aloitus oikean reunan lähelle
        const cont = document.getElementById('timeline-container');
        const r = cont.getBoundingClientRect();
        const start = { x: Math.round(r.left + r.width * 0.5), y: cTap.y };
        // tap + ripple uudessa paikassa → käyttäjälle selkeä vihje "aloita täältä"
        tapRipple(start.x, start.y);
        await sleep(260);

        // tuo "sormi" näkyviin suoraan uuteen kohtaan (ei liukua)
        cursor = ensureTouchCursor();
        moveTouchCursorInstant(cursor, start.x, start.y, true);
        await sleep(180);

        // Zoom (reversed mapping): swipe LEFT = zoom IN, swipe RIGHT = zoom OUT
        const dx = 120;  // swipe distance
        const kIn = 1.5;  // +50%
        const kOut = 0.8;  // −20%

        // zoom in — drag LEFT from start to start - dx, anchor at start
        moveTouchCursor(cursor, start.x - dx, start.y, true);
        api.animScaleBy(kIn, start.x, start.y, 700);
        await sleep(740);

        // zoom out — drag RIGHT back to start, anchor at the left end
        moveTouchCursor(cursor, start.x, start.y, true);
        api.animScaleBy(kOut, start.x - dx, start.y, 560);
        await sleep(600);

        // 3) Scroll: ylös ja alas samasta start-kohdasta
        await sleep(500);
        const dy = -90;
        moveTouchCursor(cursor, start.x, start.y + dy, true);
        api.animTranslateBy(0, dy, 620);
        await sleep(660);

        moveTouchCursor(cursor, start.x, start.y, true);
        api.animTranslateBy(0, -dy, 520);
        await sleep(540);

        hideTouchCursor(cursor);
  }

  // Aja kerran / sessio (ohitus: ?demo=1)
  document.addEventListener('timeline:ready', () => {
    if (matchMedia('(prefers-reduced-motion: reduce)').matches) return;

        const url = new URL(location.href);
        const force = url.searchParams.get('demo') === '1';
        const SS_KEY = 'startup_v41_shown';

        if (!force) {
      if (sessionStorage.getItem(SS_KEY) === '1') return;
        sessionStorage.setItem(SS_KEY, '1');
    }
        setTimeout(runStartup, 380);
        const infoToggle = document.getElementById('info-toggle');
      const infoBox = document.getElementById('info-box');

      if (infoToggle && infoBox) {
          infoToggle.addEventListener('click', async (e) => {
              // Intercept only the first click on "?" so our sequence runs first.
              e.preventDefault();
              e.stopPropagation();

              // Play the same startup animation regardless of session flag
              await runStartup();

              // Open the info box after animation
              infoBox.hidden = false;
              infoBox.style.display = 'block';
          }, { capture: true, once: true });
      }

  });
})();
</script>

</body>

</html>